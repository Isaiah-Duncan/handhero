<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandHero | Exercise Session</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-cream: #fdfbf7;
            --color-sage: #87a878;
            --color-sage-dark: #6b9960;
            --color-coral: #e8998d;
            --color-gold: #d4a574;
            --color-slate: #4a5568;
            --color-slate-light: #718096;
            
            --zone-green: rgba(104, 200, 150, 0.45);
            --zone-green-solid: #68c896;
            --zone-blue: rgba(100, 180, 230, 0.45);
            --zone-blue-solid: #64b4e6;
            --zone-yellow: rgba(240, 200, 100, 0.45);
            --zone-yellow-solid: #f0c864;
            --zone-orange: rgba(240, 160, 100, 0.45);
            --zone-orange-solid: #f0a064;
            --zone-red: rgba(230, 130, 130, 0.45);
            --zone-red-solid: #e68282;
            
            --skeleton-color: #78dcb4;
            --target-glow: #5fffb0;
            --guide-line: rgba(255, 255, 255, 0.7);
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
            user-select: none;
            height: 100vh;
        }
        
        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video-container {
            position: absolute;
            inset: 0;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.85;
        }
        
        #canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        /* HUD - Top Bar */
        .hud-top {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 100%);
            z-index: 10;
        }
        
        .exercise-card {
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px 28px;
            border: 1px solid rgba(255,255,255,0.15);
        }
        
        .exercise-header {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .exercise-icon {
            font-size: 2.8rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }
        
        .exercise-text h2 {
            font-size: 1.4rem;
            font-weight: 800;
            margin-bottom: 4px;
        }
        
        .exercise-text p {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        /* Phase Progress Dots */
        .phase-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 16px;
        }
        
        .phase-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.25);
            transition: all 0.3s ease;
        }
        
        .phase-dot.active {
            background: var(--target-glow);
            box-shadow: 0 0 12px var(--target-glow);
            transform: scale(1.3);
        }
        
        .phase-dot.complete {
            background: var(--zone-green-solid);
        }
        
        .phase-connector {
            width: 30px;
            height: 2px;
            background: rgba(255,255,255,0.2);
        }
        
        .phase-connector.complete {
            background: var(--zone-green-solid);
        }
        
        .phase-label {
            margin-left: 12px;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--target-glow);
        }
        
        /* Stats Card */
        .stats-card {
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 16px 24px;
            border: 1px solid rgba(255,255,255,0.15);
            text-align: center;
            min-width: 140px;
        }
        
        .stats-row {
            display: flex;
            gap: 20px;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 900;
        }
        
        .stat-value.green { color: var(--zone-green-solid); }
        .stat-value.blue { color: var(--zone-blue-solid); }
        .stat-value.yellow { color: var(--zone-yellow-solid); }
        .stat-value.red { color: var(--zone-red-solid); }
        
        .stat-label {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            opacity: 0.7;
            letter-spacing: 0.5px;
        }
        
        /* HUD - Bottom Bar */
        .hud-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            background: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 100%);
            z-index: 10;
        }
        
        .session-progress {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .progress-dots {
            display: flex;
            gap: 6px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s;
        }
        
        .progress-dot.complete {
            background: var(--zone-green-solid);
        }
        
        .progress-dot.current {
            background: white;
            box-shadow: 0 0 10px white;
        }
        
        .progress-text {
            font-size: 0.9rem;
            font-weight: 700;
            opacity: 0.8;
        }
        
        .controls {
            display: flex;
            gap: 12px;
        }
        
        .ctrl-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .ctrl-btn:hover {
            transform: scale(1.1);
        }
        
        .ctrl-btn.home {
            background: linear-gradient(135deg, #e68282, #d46a6a);
            color: white;
        }
        
        .ctrl-btn.skip {
            background: linear-gradient(135deg, #64b4e6, #4a9ed0);
            color: white;
        }
        
        .ctrl-btn.audio {
            background: rgba(255,255,255,0.15);
            color: white;
        }
        
        .ctrl-btn.audio.muted {
            opacity: 0.5;
        }
        
        /* Center Palm Display */
        .palm-display {
            position: absolute;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transform: translate(-50%, -50%);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .palm-display.visible {
            opacity: 1;
        }
        
        .palm-circle {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 3px solid var(--target-glow);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(95, 255, 176, 0.4);
        }
        
        .palm-value {
            font-size: 2.2rem;
            font-weight: 900;
            line-height: 1;
        }
        
        .palm-label {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            opacity: 0.8;
            margin-top: 2px;
        }
        
        .palm-circle.success {
            border-color: var(--zone-green-solid);
            background: rgba(104, 200, 150, 0.3);
        }
        
        .palm-circle.success .palm-value {
            color: var(--zone-green-solid);
        }
        
        /* Feedback Overlays */
        .feedback-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 30;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .feedback-overlay.show {
            opacity: 1;
        }
        
        .feedback-content {
            text-align: center;
        }
        
        .feedback-icon {
            font-size: 5rem;
            animation: bounce-in 0.5s ease-out;
        }
        
        .feedback-text {
            font-size: 2rem;
            font-weight: 800;
            margin-top: 10px;
            text-shadow: 0 4px 20px rgba(0,0,0,0.5);
            white-space: pre-line;
        }
        
        @keyframes bounce-in {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .rep-complete {
            position: absolute;
            font-size: 3rem;
            font-weight: 900;
            color: var(--zone-green-solid);
            text-shadow: 0 0 20px var(--zone-green-solid);
            animation: rep-pop 0.8s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes rep-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -80%) scale(1.5); opacity: 0; }
        }
        
        .level-up {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0;
            z-index: 35;
        }
        
        .level-up.show {
            animation: level-flash 1.5s ease-out;
        }
        
        .level-up-content {
            text-align: center;
            animation: level-bounce 1.5s ease-out;
        }
        
        .level-up-icon {
            font-size: 6rem;
        }
        
        .level-up-text {
            font-size: 2.5rem;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
        }
        
        @keyframes level-flash {
            0% { opacity: 0; }
            20% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        @keyframes level-bounce {
            0% { transform: scale(0); }
            30% { transform: scale(1.3); }
            50% { transform: scale(1); }
            100% { transform: scale(1); opacity: 0; }
        }
        
        /* Start Overlay */
        .start-overlay {
            position: absolute;
            inset: 0;
            background: rgba(26, 26, 46, 0.97);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .start-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-content {
            text-align: center;
            max-width: 500px;
            padding: 40px;
        }
        
        .start-logo {
            font-size: 5rem;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .start-title {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #78dcb4, #64b4e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .start-desc {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .start-btn {
            background: linear-gradient(135deg, var(--color-sage), var(--color-sage-dark));
            color: white;
            border: none;
            padding: 18px 50px;
            border-radius: 50px;
            font-family: inherit;
            font-size: 1.2rem;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(135, 168, 120, 0.5);
            transition: all 0.3s;
        }
        
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 50px rgba(135, 168, 120, 0.6);
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.2);
            border-top-color: var(--target-glow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-rise 2s ease-out forwards;
        }
        
        @keyframes particle-rise {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="hud-top">
            <div class="exercise-card">
                <div class="exercise-header">
                    <span class="exercise-icon" id="ex-icon">‚òùÔ∏è</span>
                    <div class="exercise-text">
                        <h2 id="ex-name">Index Finger Isolation</h2>
                        <p id="ex-desc">Extend only your index finger</p>
                    </div>
                </div>
                <div class="phase-progress">
                    <div class="phase-dot" id="phase-0"></div>
                    <div class="phase-connector" id="conn-0"></div>
                    <div class="phase-dot" id="phase-1"></div>
                    <div class="phase-connector" id="conn-1"></div>
                    <div class="phase-dot" id="phase-2"></div>
                    <div class="phase-connector" id="conn-2"></div>
                    <div class="phase-dot" id="phase-3"></div>
                    <div class="phase-connector" id="conn-3"></div>
                    <div class="phase-dot" id="phase-4"></div>
                    <span class="phase-label" id="phase-label">Begin</span>
                </div>
            </div>
            
            <div class="stats-row">
                <div class="stats-card">
                    <div class="stat-value" id="accuracy-value">0%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
                <div class="stats-card">
                    <div class="stat-value" id="streak-value">0</div>
                    <div class="stat-label">Streak</div>
                </div>
            </div>
        </div>
        
        <div class="hud-bottom">
            <div class="session-progress">
                <div class="progress-dots" id="progress-dots"></div>
                <span class="progress-text" id="progress-text">1 / 6</span>
            </div>
            
            <div class="controls">
                <button class="ctrl-btn audio" id="btn-audio">üîä</button>
                <button class="ctrl-btn skip" id="btn-skip">‚è≠Ô∏è</button>
                <button class="ctrl-btn home" id="btn-home">‚úï</button>
            </div>
        </div>
        
        <div class="palm-display" id="palm-display">
            <div class="palm-circle" id="palm-circle">
                <span class="palm-value" id="palm-value">3</span>
                <span class="palm-label" id="palm-label">seconds</span>
            </div>
        </div>
        
        <div class="feedback-overlay" id="feedback-overlay">
            <div class="feedback-content">
                <div class="feedback-icon" id="feedback-icon">‚úì</div>
                <div class="feedback-text" id="feedback-text">Perfect!</div>
            </div>
        </div>
        
        <div class="level-up" id="level-up">
            <div class="level-up-content">
                <div class="level-up-icon">‚≠ê</div>
                <div class="level-up-text">Level Up!</div>
            </div>
        </div>
        
        <div class="start-overlay" id="start-overlay">
            <div class="start-content">
                <div class="start-logo">üñêÔ∏è</div>
                <h1 class="start-title">HandHero</h1>
                <p class="start-desc">
                    Guided hand rehabilitation exercises using boundary-based tracking. 
                    Follow the targets, complete the movements, track your progress.
                </p>
                <button class="start-btn" id="start-btn">Start Session</button>
                <div class="loading-spinner" id="loading-spinner"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
        BOUNDARY: {
            GREEN_THRESHOLD: 0.12,
            YELLOW_THRESHOLD: 0.04,
            TARGET_EXTENSION_MIN: 0.06,
            TARGET_RATIO_MIN: 1.1
        },
        SKELETON_COLOR: '#78dcb4',
        TARGET_COLOR: '#5fffb0'
    };
    
    const FINGER_TIPS = [4, 8, 12, 16, 20];
    const FINGER_BASES = [1, 5, 9, 13, 17];
    const FINGER_NAMES = ['THUMB', 'INDEX', 'MIDDLE', 'RING', 'PINKY'];
    
    const CONNECTIONS = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
    ];
    
    // ============================================
    // EXERCISES
    // ============================================
    const EXERCISES = [
        { id: 'index', name: 'Index Finger', icon: '‚òùÔ∏è', desc: 'Extend only your index finger', type: 'isolation', mode: 'time', holdSeconds: 3, targetFingers: [1] },
        { id: 'middle', name: 'Middle Finger', icon: 'üñï', desc: 'Extend only your middle finger', type: 'isolation', mode: 'time', holdSeconds: 3, targetFingers: [2] },
        { id: 'ring', name: 'Ring Finger', icon: 'üíç', desc: 'Extend only your ring finger', type: 'isolation', mode: 'time', holdSeconds: 4, targetFingers: [3] },
        { id: 'pinky', name: 'Pinky Finger', icon: 'ü§ô', desc: 'Extend only your pinky finger', type: 'isolation', mode: 'time', holdSeconds: 3, targetFingers: [4] },
        { id: 'peace', name: 'Peace Sign', icon: '‚úåÔ∏è', desc: 'Extend index and middle fingers', type: 'isolation', mode: 'time', holdSeconds: 3, targetFingers: [1, 2] },
        { id: 'starfish', name: 'Starfish Spread', icon: 'üåü', desc: 'Spread all fingers wide', type: 'spread', mode: 'time', holdSeconds: 4, targetFingers: [0,1,2,3,4] },
        { id: 'taps', name: 'Finger Taps', icon: 'üëÜ', desc: 'Tap your index finger up and down', type: 'rep', mode: 'reps', targetReps: 5, targetFingers: [1] },
        { id: 'twister', name: 'Finger Twister', icon: 'üéØ', desc: 'Touch the highlighted fingers together', type: 'twister', mode: 'reps', targetReps: 3, touchSequence: [{from:0,to:1},{from:0,to:2},{from:0,to:4}] }
    ];
    
    // ============================================
    // STATE
    // ============================================
    const state = {
        hands: null, camera: null, landmarks: null,
        currentExerciseIndex: 0, sessionExercises: [], completedCount: 0, streak: 0,
        totalAccuracy: 0, accuracyReadings: 0,
        phase: 'BEGIN', phaseStartTime: 0,
        currentAccuracy: 0, holdStartTime: 0, isHolding: false, timeRemaining: 0,
        currentRep: 0, repState: 'down',
        twisterStep: 0, nodeReached: false,
        palmX: 0, palmY: 0,
        audioEnabled: true, audioCtx: null,
        animFrame: 0
    };
    
    const $ = id => document.getElementById(id);
    const video = $('video');
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    
    // ============================================
    // BOUNDARY ENGINE
    // ============================================
    const Engine = {
        getFrame(lm) {
            const wrist = lm[0], middleTip = lm[12], indexBase = lm[5], pinkyBase = lm[17];
            const handHeight = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y, (middleTip.z||0) - (wrist.z||0));
            const handWidth = Math.hypot(pinkyBase.x - indexBase.x, pinkyBase.y - indexBase.y);
            const palmCenter = {
                x: (lm[0].x + lm[5].x + lm[9].x + lm[13].x + lm[17].x) / 5,
                y: (lm[0].y + lm[5].y + lm[9].y + lm[13].y + lm[17].y) / 5
            };
            return { handHeight, handWidth, palmCenter, wrist };
        },
        
        checkExtended(i, lm, f) {
            const tip = lm[FINGER_TIPS[i]], base = lm[FINGER_BASES[i]], wrist = lm[0];
            const above = base.y - tip.y, norm = above / f.handHeight;
            const tipDist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const baseDist = Math.hypot(base.x - wrist.x, base.y - wrist.y);
            const ratio = tipDist / baseDist;
            
            if (norm > CONFIG.BOUNDARY.TARGET_EXTENSION_MIN && ratio > CONFIG.BOUNDARY.TARGET_RATIO_MIN)
                return { zone: 'GREEN', score: 1.0 };
            if (norm > 0.02 && ratio > 1.0) return { zone: 'BLUE', score: 0.80 };
            if (norm > -0.03 && ratio > 0.9) return { zone: 'YELLOW', score: 0.60 };
            return { zone: 'RED', score: Math.max(0.2, 0.5 + norm) };
        },
        
        checkCurled(i, lm, f) {
            const tip = lm[FINGER_TIPS[i]], base = lm[FINGER_BASES[i]];
            const below = tip.y - base.y, norm = below / f.handHeight;
            
            if (norm >= CONFIG.BOUNDARY.GREEN_THRESHOLD) return { zone: 'GREEN', score: 1.0 };
            if (norm >= CONFIG.BOUNDARY.YELLOW_THRESHOLD) {
                const p = (norm - CONFIG.BOUNDARY.YELLOW_THRESHOLD) / (CONFIG.BOUNDARY.GREEN_THRESHOLD - CONFIG.BOUNDARY.YELLOW_THRESHOLD);
                return { zone: 'YELLOW', score: 0.65 + p * 0.20 };
            }
            if (norm >= 0) return { zone: 'ORANGE', score: 0.40 + norm * 2 };
            return { zone: 'RED', score: Math.max(0.15, 0.40 + norm) };
        },
        
        evalIsolation(lm, targets) {
            const f = this.getFrame(lm);
            const results = [];
            let total = 0;
            
            for (let i = 0; i < 5; i++) {
                const isTarget = targets.includes(i);
                const r = isTarget ? this.checkExtended(i, lm, f) : this.checkCurled(i, lm, f);
                r.isTarget = isTarget;
                r.finger = FINGER_NAMES[i];
                results.push(r);
                total += r.score;
            }
            
            const acc = total / 5;
            let zone = 'RED';
            if (acc >= 0.85) zone = 'GREEN';
            else if (acc >= 0.65) zone = 'BLUE';
            else if (acc >= 0.45) zone = 'YELLOW';
            
            return { accuracy: acc, zone, results, frame: f, passed: acc >= 0.65 };
        },
        
        evalSpread(lm) {
            const f = this.getFrame(lm);
            const tips = FINGER_TIPS.map(i => lm[i]);
            
            let extScore = 0;
            const results = [];
            for (let i = 0; i < 5; i++) {
                const r = this.checkExtended(i, lm, f);
                r.isTarget = true;
                r.finger = FINGER_NAMES[i];
                results.push(r);
                extScore += r.score;
            }
            extScore /= 5;
            
            let gapScore = 0;
            const gaps = [];
            for (let i = 0; i < 4; i++) {
                const gap = Math.hypot(tips[i+1].x - tips[i].x, tips[i+1].y - tips[i].y);
                const norm = gap / f.handWidth;
                gaps.push(norm);
                if (norm > 0.20) gapScore += 1.0;
                else if (norm > 0.12) gapScore += 0.75;
                else if (norm > 0.06) gapScore += 0.50;
                else gapScore += 0.25;
            }
            gapScore /= 4;
            
            const acc = (extScore * 0.5) + (gapScore * 0.5);
            let zone = 'RED';
            if (acc >= 0.85) zone = 'GREEN';
            else if (acc >= 0.65) zone = 'BLUE';
            else if (acc >= 0.45) zone = 'YELLOW';
            
            return { accuracy: acc, zone, results, frame: f, gaps, passed: acc >= 0.65 };
        },
        
        checkTouch(lm, from, to, f) {
            const a = lm[FINGER_TIPS[from]], b = lm[FINGER_TIPS[to]];
            const dist = Math.hypot(a.x - b.x, a.y - b.y, (a.z||0) - (b.z||0));
            const norm = dist / f.handWidth;
            return { distance: norm, touching: norm < 0.15, close: norm < 0.25 };
        }
    };
    
    // ============================================
    // INIT
    // ============================================
    async function init() {
        $('loading-spinner').style.display = 'block';
        $('start-btn').style.display = 'none';
        
        state.sessionExercises = EXERCISES.slice(0, 6);
        buildProgressDots();
        
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        state.hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        state.hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
        state.hands.onResults(onResults);
        
        state.camera = new Camera(video, {
            onFrame: async () => { await state.hands.send({ image: video }); },
            width: 1280, height: 720
        });
        
        await state.camera.start();
        $('start-overlay').classList.add('hidden');
        startExercise();
    }
    
    function buildProgressDots() {
        const c = $('progress-dots');
        c.innerHTML = '';
        state.sessionExercises.forEach((_, i) => {
            const d = document.createElement('div');
            d.className = 'progress-dot' + (i === 0 ? ' current' : '');
            d.id = 'prog-' + i;
            c.appendChild(d);
        });
    }
    
    // ============================================
    // MAIN LOOP
    // ============================================
    function onResults(results) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.animFrame++;
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.landmarks = results.multiHandLandmarks[0];
            processFrame();
        } else {
            state.landmarks = null;
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.font = 'bold 24px Nunito';
            ctx.textAlign = 'center';
            ctx.fillText('Show your hand to the camera', canvas.width/2, canvas.height/2);
        }
        updateUI();
    }
    
    function processFrame() {
        const lm = state.landmarks;
        const ex = state.sessionExercises[state.currentExerciseIndex];
        const frame = Engine.getFrame(lm);
        
        state.palmX = frame.palmCenter.x * canvas.width;
        state.palmY = frame.palmCenter.y * canvas.height;
        
        let result;
        if (ex.type === 'spread') result = Engine.evalSpread(lm);
        else if (ex.type === 'twister') result = evalTwister(lm, ex, frame);
        else result = Engine.evalIsolation(lm, ex.targetFingers);
        
        state.currentAccuracy = result.accuracy;
        state.totalAccuracy += result.accuracy;
        state.accuracyReadings++;
        
        processPhase(result, ex);
        
        renderSkeleton(lm, result);
        if (ex.type === 'spread') renderSpreadZones(lm, result);
        else if (ex.type === 'twister') renderTwister(lm, ex, frame);
        else renderBoundaries(lm, result, ex);
        renderTargets(lm, ex, result);
        updatePalm(ex);
    }
    
    function evalTwister(lm, ex, frame) {
        const touch = ex.touchSequence[state.twisterStep] || ex.touchSequence[0];
        const r = Engine.checkTouch(lm, touch.from, touch.to, frame);
        const acc = r.touching ? 1.0 : r.close ? 0.7 : Math.max(0.3, 1 - r.distance);
        return { accuracy: acc, zone: r.touching ? 'GREEN' : r.close ? 'BLUE' : 'YELLOW', passed: r.close, frame, touchResult: r };
    }
    
    // ============================================
    // PHASES
    // ============================================
    function processPhase(result, ex) {
        const now = Date.now();
        
        switch (state.phase) {
            case 'BEGIN':
                if (state.landmarks) { state.phase = 'TRANSITION'; state.phaseStartTime = now; speak(ex.desc); }
                break;
            case 'TRANSITION':
                if (result.accuracy >= 0.50) { state.phase = 'SIGNAL'; state.phaseStartTime = now; playTone(440, 0.1); }
                break;
            case 'SIGNAL':
                if (now - state.phaseStartTime > 500) {
                    state.phase = 'EXERCISE';
                    state.phaseStartTime = now;
                    state.holdStartTime = now;
                    state.isHolding = false;
                    state.currentRep = 0;
                    state.repState = 'down';
                }
                break;
            case 'EXERCISE':
                processExercise(result, ex);
                break;
            case 'END':
                if (now - state.phaseStartTime > 1500) nextExercise();
                break;
        }
    }
    
    function processExercise(result, ex) {
        const now = Date.now();
        
        if (ex.mode === 'time') {
            if (result.passed) {
                if (!state.isHolding) { state.isHolding = true; state.holdStartTime = now; }
                const elapsed = now - state.holdStartTime;
                const total = ex.holdSeconds * 1000;
                state.timeRemaining = Math.max(0, total - elapsed) / 1000;
                if (elapsed >= total) exerciseComplete();
            } else {
                if (state.isHolding) {
                    const elapsed = now - state.holdStartTime;
                    state.holdStartTime = now - Math.max(0, elapsed - 200);
                }
                state.isHolding = false;
                state.timeRemaining = ex.holdSeconds;
            }
        } else if (ex.mode === 'reps') {
            if (ex.type === 'twister') processTwisterRep(ex);
            else processFingerRep(result, ex);
        }
    }
    
    function processFingerRep(result, ex) {
        const fr = result.results[ex.targetFingers[0]];
        if (state.repState === 'down') {
            if (fr.zone === 'GREEN' || fr.zone === 'BLUE') state.repState = 'up';
        } else {
            if (fr.zone === 'RED' || fr.score < 0.5) {
                state.currentRep++;
                state.repState = 'down';
                playTone(523, 0.1);
                spawnRep();
                if (state.currentRep >= ex.targetReps) exerciseComplete();
            }
        }
    }
    
    function processTwisterRep(ex) {
        const touch = ex.touchSequence[state.twisterStep];
        const frame = Engine.getFrame(state.landmarks);
        const r = Engine.checkTouch(state.landmarks, touch.from, touch.to, frame);
        
        if (r.touching && !state.nodeReached) { state.nodeReached = true; playTone(659, 0.1); }
        else if (!r.close && state.nodeReached) {
            state.twisterStep++;
            state.nodeReached = false;
            state.currentRep++;
            spawnRep();
            if (state.twisterStep >= ex.touchSequence.length) exerciseComplete();
        }
    }
    
    function exerciseComplete() {
        state.phase = 'END';
        state.phaseStartTime = Date.now();
        state.streak++;
        state.completedCount++;
        playSuccess();
        showFeedback('‚úì', getRandomPraise());
        spawnParticles();
        if (state.completedCount > 0 && state.completedCount % 3 === 0) setTimeout(showLevelUp, 500);
    }
    
    // ============================================
    // RENDERING
    // ============================================
    function renderSkeleton(lm, result) {
        ctx.strokeStyle = CONFIG.SKELETON_COLOR;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        for (const [i, j] of CONNECTIONS) {
            ctx.beginPath();
            ctx.moveTo(lm[i].x * canvas.width, lm[i].y * canvas.height);
            ctx.lineTo(lm[j].x * canvas.width, lm[j].y * canvas.height);
            ctx.stroke();
        }
        
        const ex = state.sessionExercises[state.currentExerciseIndex];
        lm.forEach((p, idx) => {
            const x = p.x * canvas.width, y = p.y * canvas.height;
            const fi = getFingerIdx(idx);
            const isTip = FINGER_TIPS.includes(idx);
            const isTarget = isTip && ex.targetFingers.includes(fi);
            const size = isTarget ? 10 : isTip ? 7 : 5;
            
            if (isTarget) { ctx.shadowColor = CONFIG.TARGET_COLOR; ctx.shadowBlur = 15; }
            ctx.fillStyle = CONFIG.SKELETON_COLOR;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            if (isTip) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        });
    }
    
    function getFingerIdx(n) {
        if (n >= 1 && n <= 4) return 0;
        if (n >= 5 && n <= 8) return 1;
        if (n >= 9 && n <= 12) return 2;
        if (n >= 13 && n <= 16) return 3;
        if (n >= 17 && n <= 20) return 4;
        return -1;
    }
    
    function renderSpreadZones(lm, result) {
        const tips = FINGER_TIPS.map(i => ({ x: lm[i].x * canvas.width, y: lm[i].y * canvas.height }));
        const wrist = { x: lm[0].x * canvas.width, y: lm[0].y * canvas.height };
        
        for (let i = 0; i < 4; i++) {
            const g = result.gaps ? result.gaps[i] : 0.1;
            let color;
            if (g > 0.20) color = 'rgba(104, 200, 150, 0.35)';
            else if (g > 0.12) color = 'rgba(100, 180, 230, 0.35)';
            else if (g > 0.06) color = 'rgba(240, 200, 100, 0.35)';
            else color = 'rgba(230, 130, 130, 0.35)';
            
            ctx.beginPath();
            ctx.moveTo(tips[i].x, tips[i].y);
            ctx.lineTo(tips[i+1].x, tips[i+1].y);
            ctx.lineTo(wrist.x, wrist.y);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        const cx = tips.reduce((s, t) => s + t.x, 0) / tips.length;
        const cy = tips.reduce((s, t) => s + t.y, 0) / tips.length;
        ctx.font = 'bold 28px Nunito';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 10;
        ctx.fillText(Math.round(result.accuracy * 100) + '%', cx, cy);
        ctx.shadowBlur = 0;
    }
    
    function renderBoundaries(lm, result, ex) {
        const f = result.frame;
        for (let i = 1; i < 5; i++) {
            if (ex.targetFingers.includes(i)) continue;
            const base = lm[FINGER_BASES[i]];
            const bx = base.x * canvas.width, by = base.y * canvas.height;
            const greenY = by + (CONFIG.BOUNDARY.GREEN_THRESHOLD * f.handHeight * canvas.height);
            const yellowY = by + (CONFIG.BOUNDARY.YELLOW_THRESHOLD * f.handHeight * canvas.height);
            
            ctx.setLineDash([8, 4]);
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(104, 200, 150, 0.5)';
            ctx.beginPath(); ctx.moveTo(bx - 30, greenY); ctx.lineTo(bx + 30, greenY); ctx.stroke();
            ctx.strokeStyle = 'rgba(240, 200, 100, 0.5)';
            ctx.beginPath(); ctx.moveTo(bx - 25, yellowY); ctx.lineTo(bx + 25, yellowY); ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    function renderTwister(lm, ex, frame) {
        if (!ex.touchSequence || state.twisterStep >= ex.touchSequence.length) return;
        const t = ex.touchSequence[state.twisterStep];
        const from = lm[FINGER_TIPS[t.from]], to = lm[FINGER_TIPS[t.to]];
        const fx = from.x * canvas.width, fy = from.y * canvas.height;
        const tx = to.x * canvas.width, ty = to.y * canvas.height;
        
        ctx.setLineDash([10, 8]);
        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
        ctx.setLineDash([]);
        
        const pulse = 1 + Math.sin(state.animFrame * 0.1) * 0.15;
        ctx.fillStyle = state.nodeReached ? 'rgba(104, 200, 150, 0.6)' : 'rgba(95, 255, 176, 0.4)';
        ctx.beginPath(); ctx.arc(tx, ty, 35 * pulse, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = state.nodeReached ? '#68c896' : CONFIG.TARGET_COLOR;
        ctx.beginPath(); ctx.arc(tx, ty, 15, 0, Math.PI * 2); ctx.fill();
        
        if (state.nodeReached) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Nunito';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚úì', tx, ty);
        }
    }
    
    function renderTargets(lm, ex, result) {
        if (ex.type === 'twister') return;
        ex.targetFingers.forEach(fi => {
            const tip = lm[FINGER_TIPS[fi]];
            const x = tip.x * canvas.width, y = tip.y * canvas.height;
            const fr = result.results ? result.results[fi] : null;
            const good = fr && (fr.zone === 'GREEN' || fr.zone === 'BLUE');
            const pulse = 1 + Math.sin(state.animFrame * 0.08) * 0.1;
            ctx.fillStyle = good ? 'rgba(104, 200, 150, 0.4)' : 'rgba(95, 255, 176, 0.25)';
            ctx.beginPath(); ctx.arc(x, y, 30 * pulse, 0, Math.PI * 2); ctx.fill();
        });
    }
    
    // ============================================
    // UI
    // ============================================
    function updateUI() {
        const ex = state.sessionExercises[state.currentExerciseIndex];
        $('ex-icon').textContent = ex.icon;
        $('ex-name').textContent = ex.name;
        $('ex-desc').textContent = ex.desc;
        
        const pct = Math.round(state.currentAccuracy * 100);
        const av = $('accuracy-value');
        av.textContent = pct + '%';
        av.className = 'stat-value ' + zoneClass(state.currentAccuracy);
        
        $('streak-value').textContent = state.streak;
        
        const phases = ['BEGIN', 'TRANSITION', 'SIGNAL', 'EXERCISE', 'END'];
        const pi = phases.indexOf(state.phase);
        phases.forEach((_, i) => {
            const d = $('phase-' + i), c = $('conn-' + i);
            if (i < pi) { d.className = 'phase-dot complete'; if (c) c.className = 'phase-connector complete'; }
            else if (i === pi) { d.className = 'phase-dot active'; if (c) c.className = 'phase-connector'; }
            else { d.className = 'phase-dot'; if (c) c.className = 'phase-connector'; }
        });
        
        const labels = { 'BEGIN': 'Ready...', 'TRANSITION': 'Get in position', 'SIGNAL': 'Almost there!', 'EXERCISE': ex.mode === 'time' ? 'Hold steady!' : 'Keep going!', 'END': 'Great job!' };
        $('phase-label').textContent = labels[state.phase];
        
        state.sessionExercises.forEach((_, i) => {
            const d = $('prog-' + i);
            if (!d) return;
            if (i < state.currentExerciseIndex) d.className = 'progress-dot complete';
            else if (i === state.currentExerciseIndex) d.className = 'progress-dot current';
            else d.className = 'progress-dot';
        });
        $('progress-text').textContent = `${state.currentExerciseIndex + 1} / ${state.sessionExercises.length}`;
    }
    
    function updatePalm(ex) {
        const d = $('palm-display'), c = $('palm-circle'), v = $('palm-value'), l = $('palm-label');
        if (state.phase !== 'EXERCISE' || !state.landmarks) { d.classList.remove('visible'); return; }
        d.classList.add('visible');
        d.style.left = state.palmX + 'px';
        d.style.top = state.palmY + 'px';
        
        if (ex.mode === 'time') {
            const r = Math.ceil(state.timeRemaining);
            v.textContent = r;
            l.textContent = 'seconds';
            c.className = 'palm-circle' + (r <= 1 && state.isHolding ? ' success' : '');
        } else {
            v.textContent = `${state.currentRep}/${ex.targetReps}`;
            l.textContent = 'reps';
            c.className = 'palm-circle';
        }
    }
    
    function zoneClass(a) {
        if (a >= 0.85) return 'green';
        if (a >= 0.65) return 'blue';
        if (a >= 0.45) return 'yellow';
        return 'red';
    }
    
    // ============================================
    // NAVIGATION
    // ============================================
    function startExercise() {
        const ex = state.sessionExercises[state.currentExerciseIndex];
        state.phase = 'BEGIN';
        state.phaseStartTime = Date.now();
        state.isHolding = false;
        state.holdStartTime = 0;
        state.timeRemaining = ex.holdSeconds || 3;
        state.currentRep = 0;
        state.repState = 'down';
        state.twisterStep = 0;
        state.nodeReached = false;
        updateUI();
    }
    
    function nextExercise() {
        if (state.currentExerciseIndex < state.sessionExercises.length - 1) {
            state.currentExerciseIndex++;
            startExercise();
        } else {
            const avg = state.accuracyReadings > 0 ? Math.round((state.totalAccuracy / state.accuracyReadings) * 100) : 0;
            showFeedback('üéâ', `Session Complete!\nAverage: ${avg}%`);
        }
    }
    
    function skipExercise() { state.streak = 0; nextExercise(); }
    
    // ============================================
    // EFFECTS
    // ============================================
    function showFeedback(icon, text) {
        $('feedback-icon').textContent = icon;
        $('feedback-text').textContent = text;
        $('feedback-overlay').classList.add('show');
        setTimeout(() => $('feedback-overlay').classList.remove('show'), 1500);
    }
    
    function showLevelUp() {
        $('level-up').classList.add('show');
        playTone(523, 0.1);
        setTimeout(() => playTone(659, 0.1), 150);
        setTimeout(() => playTone(784, 0.15), 300);
        setTimeout(() => $('level-up').classList.remove('show'), 1500);
    }
    
    function spawnRep() {
        const d = document.createElement('div');
        d.className = 'rep-complete';
        d.textContent = '+1';
        d.style.left = state.palmX + 'px';
        d.style.top = state.palmY + 'px';
        document.body.appendChild(d);
        setTimeout(() => d.remove(), 800);
    }
    
    function spawnParticles() {
        const colors = ['#68c896', '#64b4e6', '#f0c864', '#78dcb4'];
        for (let i = 0; i < 20; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.left = (state.palmX + (Math.random() - 0.5) * 100) + 'px';
            p.style.top = (state.palmY + (Math.random() - 0.5) * 100) + 'px';
            p.style.width = p.style.height = (5 + Math.random() * 10) + 'px';
            p.style.background = colors[Math.floor(Math.random() * colors.length)];
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 2000);
        }
    }
    
    function getRandomPraise() {
        return ['Perfect!', 'Excellent!', 'Great job!', 'Nailed it!', 'Amazing!'][Math.floor(Math.random() * 5)];
    }
    
    // ============================================
    // AUDIO
    // ============================================
    function playTone(freq, dur) {
        if (!state.audioEnabled || !state.audioCtx) return;
        const o = state.audioCtx.createOscillator(), g = state.audioCtx.createGain();
        o.connect(g); g.connect(state.audioCtx.destination);
        o.type = 'sine'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.1, state.audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, state.audioCtx.currentTime + dur);
        o.start(); o.stop(state.audioCtx.currentTime + dur);
    }
    
    function playSuccess() { playTone(523, 0.1); setTimeout(() => playTone(659, 0.1), 100); setTimeout(() => playTone(784, 0.15), 200); }
    
    function speak(t) {
        if (!state.audioEnabled || !window.speechSynthesis) return;
        speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(t);
        u.rate = 0.9;
        speechSynthesis.speak(u);
    }
    
    function toggleAudio() {
        state.audioEnabled = !state.audioEnabled;
        $('btn-audio').textContent = state.audioEnabled ? 'üîä' : 'üîá';
        $('btn-audio').classList.toggle('muted', !state.audioEnabled);
    }
    
    // ============================================
    // EVENTS
    // ============================================
    $('start-btn').addEventListener('click', init);
    $('btn-audio').addEventListener('click', toggleAudio);
    $('btn-skip').addEventListener('click', skipExercise);
    $('btn-home').addEventListener('click', () => { if (confirm('End session?')) window.location.href = 'handhero_dashboard.html'; });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === ' ') skipExercise();
        if (e.key === 'Escape') $('btn-home').click();
        if (e.key === 'm') toggleAudio();
    });
    </script>
</body>
</html>