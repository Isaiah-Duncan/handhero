<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandHero | Hand Therapy Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="InvisibleBoundaryEngine.js"></script>
    <script src="BoundaryVisualizer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-cream: #fdfbf7;
            --color-warm-white: #faf8f5;
            --color-sage: #87a878;
            --color-sage-dark: #6b9960;
            --color-sage-light: #a8c99b;
            --color-coral: #e8998d;
            --color-gold: #d4a574;
            --color-slate: #4a5568;
            --color-slate-light: #718096;
            --color-success: #68b37a;
            --zone-green: rgba(104, 200, 150, 0.5);
            --zone-green-solid: #68c896;
            --zone-blue: rgba(100, 180, 230, 0.5);
            --zone-blue-solid: #64b4e6;
            --zone-yellow: rgba(240, 200, 100, 0.5);
            --zone-yellow-solid: #f0c864;
            --zone-red: rgba(230, 130, 130, 0.4);
            --zone-red-solid: #e68282;
            --skeleton-neutral: #78dcb4;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Nunito', sans-serif; 
            background: var(--color-cream); 
            color: var(--color-slate); 
            overflow: hidden; 
            user-select: none;
        }
        *:focus-visible { outline: 3px solid var(--color-sage); outline-offset: 2px; }
        
        #app-container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        
        #video-bg { 
            position: absolute; 
            inset: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            filter: blur(30px) opacity(0.4) sepia(0.1); 
            z-index: 0;
        }
        
        #portal-wrapper { 
            position: relative; 
            width: 92vw; 
            height: 88vh; 
            max-width: 1200px; 
            z-index: 10; 
        }
        
        #portal-frame {
            position: relative;
            width: 100%; 
            height: 100%;
            border-radius: 32px;
            padding: 4px;
            background: linear-gradient(135deg, var(--color-sage), var(--color-gold), var(--color-coral));
            background-size: 200% 200%;
            animation: gradient-flow 10s ease infinite;
            box-shadow: 0 20px 60px -10px rgba(135, 168, 120, 0.25);
            transition: all 0.4s ease;
        }
        
        #portal-frame.holding { background: linear-gradient(135deg, var(--color-gold), #e8c9a8); box-shadow: 0 0 50px rgba(212, 165, 116, 0.5); }
        #portal-frame.success { background: linear-gradient(135deg, var(--color-success), var(--color-sage-light)); box-shadow: 0 0 60px rgba(104, 179, 122, 0.6); }
        #portal-frame.ready { background: linear-gradient(135deg, #a8c99b, #c9dfc0); }
        #portal-frame.reset { background: linear-gradient(135deg, #b8a8c9, #c9c0df); }
        
        @keyframes gradient-flow { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }
        
        #portal-view { 
            width: 100%; 
            height: 100%; 
            background: var(--color-warm-white); 
            border-radius: 28px; 
            overflow: hidden; 
            position: relative; 
        }
        
        #video-clean { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 100vw; 
            height: 100vh; 
            object-fit: cover; 
            transform: translate(-50%, -50%) scaleX(-1); 
        }
        
        #output-canvas { 
            position: absolute; 
            inset: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
        }
        
        /* HUD */
        #hud-layer { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            padding: 20px; 
        }
        
        .top-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
        
        .glass-pill {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
        }
        
        .instruction-banner { padding: 14px 28px; display: flex; align-items: center; gap: 16px; max-width: 480px; }
        .instruction-icon { font-size: 1.8rem; }
        .instruction-text { font-size: 1.2rem; font-weight: 700; color: var(--color-slate); }
        .instruction-sub { font-size: 0.9rem; color: var(--color-slate-light); font-weight: 500; margin-top: 2px; }
        
        /* Phase indicator */
        .phase-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .phase-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s;
        }
        .phase-dot.active { background: var(--color-sage); transform: scale(1.2); }
        .phase-dot.complete { background: var(--color-success); }
        .phase-label {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--color-sage);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .progress-pill { padding: 10px 16px; font-size: 0.8rem; font-weight: 600; color: var(--color-slate-light); }
        
        .stats-bar { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }
        .stat-card { padding: 10px 18px; border-radius: 16px; display: flex; align-items: center; gap: 10px; }
        .stat-val { font-size: 1.2rem; font-weight: 700; color: var(--color-slate); }
        .stat-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--color-slate-light); font-weight: 700; }
        
        /* Color Indicator (replaces accuracy percentage) */
        .accuracy-indicator {
            padding: 12px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        .zone-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }
        .zone-dot.green { background: var(--zone-green-solid); box-shadow: 0 0 20px var(--zone-green-solid); }
        .zone-dot.blue { background: var(--zone-blue-solid); box-shadow: 0 0 15px var(--zone-blue-solid); }
        .zone-dot.yellow { background: var(--zone-yellow-solid); box-shadow: 0 0 15px var(--zone-yellow-solid); }
        .zone-dot.red { background: var(--zone-red-solid); }
        .zone-label {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--color-slate-light);
        }
        
        /* Floating Buttons */
        .float-btn {
            position: fixed;
            z-index: 50;
            background: white;
            color: var(--color-slate);
            border: 1px solid #e8e4df;
            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
            border-radius: 14px;
            padding: 12px;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            transition: all 0.2s;
        }
        .float-btn:hover { background: var(--color-warm-white); transform: translateY(-2px); }
        #btn-home { top: 20px; left: 20px; }
        #btn-audio { top: 20px; left: 80px; }
        #btn-skip { top: 20px; right: 20px; background: #fef7ed; border-color: var(--color-gold); }
        #btn-ibe { top: 20px; right: 80px; }

        .float-btn.active { background: linear-gradient(135deg, var(--color-sage) 0%, var(--color-sage-dark) 100%); color: white; border-color: transparent; }
        
        /* Progress Bar */
        #progress-bar-container { 
            position: absolute; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            height: 8px; 
            background: rgba(0,0,0,0.05); 
            border-radius: 0 0 28px 28px; 
            overflow: hidden; 
        }
        #progress-bar-fill { 
            height: 100%; 
            width: 0%; 
            background: linear-gradient(90deg, var(--color-sage), var(--color-success)); 
            transition: width 300ms cubic-bezier(0.22, 0.9, 0.32, 1);
        }
        
        /* Center Feedback */
        .center-feedback { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            text-align: center; 
            pointer-events: none; 
        }
        #hold-timer { 
            font-size: 5rem; 
            font-weight: 800; 
            color: white; 
            text-shadow: 0 4px 30px rgba(0,0,0,0.3); 
            opacity: 0; 
            transition: opacity 0.2s; 
        }
        #hold-timer.show { opacity: 1; }
        #feedback-message { 
            font-size: 2.8rem; 
            font-weight: 800; 
            color: var(--color-success); 
            text-shadow: 0 4px 20px rgba(104, 179, 122, 0.4); 
            opacity: 0; 
            transform: scale(0.5); 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        }
        #feedback-message.show { opacity: 1; transform: scale(1); }
        
        /* Reset Instruction Overlay */
        #reset-instruction {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #reset-instruction.show { opacity: 1; }
        .reset-icon { font-size: 4rem; margin-bottom: 16px; }
        .reset-text { 
            font-size: 1.5rem; 
            font-weight: 700; 
            color: white; 
            text-shadow: 0 2px 20px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.3);
            padding: 16px 32px;
            border-radius: 16px;
            backdrop-filter: blur(8px);
        }
        
        /* Low Light Warning */
        .low-light-warning {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(230, 130, 130, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 25;
        }
        .low-light-warning.show { opacity: 1; }
        
        /* Particles */
        .particle { position: absolute; pointer-events: none; border-radius: 50%; animation: particle-fall 1.5s ease-out forwards; }
        @keyframes particle-fall { 0% { opacity: 1; transform: translateY(0) rotate(0deg); } 100% { opacity: 0; transform: translateY(200px) rotate(720deg); } }
        
        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: white;
            padding: 16px 28px;
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 300;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .toast-icon { font-size: 1.5rem; }
        .toast-message { font-weight: 600; color: var(--color-slate); }
        
        /* Overlays */
        .overlay-screen {
            position: fixed;
            inset: 0;
            z-index: 100;
            background: rgba(253, 251, 247, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .overlay-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        .overlay-content { max-width: 500px; width: 100%; text-align: center; }
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 16px 32px;
            border-radius: 16px;
            font-size: 1.05rem;
            font-weight: 700;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--color-sage) 0%, var(--color-sage-dark) 100%);
            color: white;
            box-shadow: 0 8px 24px -4px rgba(135, 168, 120, 0.4);
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 12px 28px -4px rgba(135, 168, 120, 0.5); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-secondary { background: white; color: var(--color-slate); border: 2px solid #e8e4df; }
        .btn-secondary:hover { background: var(--color-warm-white); border-color: var(--color-sage); }
        .btn-ghost { background: transparent; color: var(--color-slate-light); padding: 12px 20px; }
        .btn-ghost:hover { color: var(--color-slate); background: rgba(0,0,0,0.03); }
        
        /* Onboarding */
        .onboarding-step { display: none; opacity: 0; transition: opacity 0.4s ease; }
        .onboarding-step.active { display: block; opacity: 1; }
        .onboarding-image { font-size: 5rem; margin-bottom: 24px; }
        .onboarding-title { font-size: 1.9rem; font-weight: 800; color: var(--color-slate); margin-bottom: 12px; }
        .onboarding-desc { font-size: 1.05rem; color: var(--color-slate-light); line-height: 1.6; margin-bottom: 32px; }
        .onboarding-dots { position: relative; display: flex; justify-content: center; gap: 8px; margin-bottom: 24px; height: 16px; align-items: center; }
        .onboarding-dot { width: 10px; height: 10px; border-radius: 50%; background: #e8e4df; transition: background 0.35s, transform 0.35s; z-index: 3; display: inline-block; }
        /* Active dot is hidden because the pill is the active indicator */
        .onboarding-dot.active {
          background: transparent;
          box-shadow: none;
          transform: none;
        }
        .onboarding-dot.completed { background: #d8d8d8; }
        .onboarding-dots .pill {
          position: absolute;
          left: 0;
          top: 50%;
          width: 28px;
          height: 10px;
          border-radius: 999px;
          background: var(--color-sage);
          transform: translate(0, -50%);
          transition: transform 780ms cubic-bezier(0.16, 1, 0.3, 1);
          will-change: transform;
          pointer-events: none;
          box-shadow: 0 6px 14px rgba(0,0,0,0.10);
          z-index: 1;
        }
        
        /* Disclaimer */
        .disclaimer-box { background: white; border: 1px solid #e8e4df; border-radius: 16px; padding: 20px; text-align: left; margin-bottom: 24px; max-height: 180px; overflow-y: auto; }
        .disclaimer-box h4 { font-weight: 700; color: var(--color-slate); margin-bottom: 8px; }
        .disclaimer-box p, .disclaimer-box ul { font-size: 0.85rem; color: var(--color-slate-light); line-height: 1.5; margin-bottom: 8px; }
        .disclaimer-box ul { padding-left: 20px; }
        .checkbox-row { display: flex; align-items: flex-start; gap: 12px; text-align: left; margin-bottom: 20px; }
        .checkbox-row input[type="checkbox"] { width: 22px; height: 22px; margin-top: 2px; accent-color: var(--color-sage); }
        .checkbox-row label { font-size: 0.9rem; color: var(--color-slate); line-height: 1.4; }
        
        /* Ready Screen */
        .ready-overlay { background: rgba(168, 201, 155, 0.97); }
        .ready-countdown { font-size: 8rem; font-weight: 800; color: white; text-shadow: 0 8px 40px rgba(0,0,0,0.15); animation: pulse-scale 1s ease infinite; }
        @keyframes pulse-scale { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .ready-exercise-preview { background: rgba(255,255,255,0.95); border-radius: 20px; padding: 24px 40px; margin-top: 32px; display: inline-flex; align-items: center; gap: 16px; }
        .ready-exercise-icon { font-size: 2.5rem; }
        .ready-exercise-name { font-size: 1.4rem; font-weight: 700; color: var(--color-slate); }
        .ready-exercise-desc { font-size: 0.9rem; color: var(--color-slate-light); }
        
        /* Pain Check */
        .pain-scale { display: flex; justify-content: space-between; gap: 10px; margin: 24px 0; }
        .pain-btn { flex: 1; padding: 18px 10px; border-radius: 14px; border: 3px solid transparent; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 6px; transition: all 0.2s; }
        .pain-btn:hover { transform: translateY(-3px); }
        .pain-btn.green { background: #e8f5e9; }
        .pain-btn.green:hover, .pain-btn.green.selected { border-color: #68b37a; background: #d4edda; }
        .pain-btn.yellow { background: #fff8e1; }
        .pain-btn.yellow:hover, .pain-btn.yellow.selected { border-color: #e8b44d; background: #ffecb3; }
        .pain-btn.orange { background: #fff3e0; }
        .pain-btn.orange:hover, .pain-btn.orange.selected { border-color: #e8998d; background: #ffe0b2; }
        .pain-btn.red { background: #ffebee; }
        .pain-btn.red:hover, .pain-btn.red.selected { border-color: #d97b7b; background: #ffcdd2; }
        .pain-emoji { font-size: 2rem; }
        .pain-label { font-size: 0.8rem; font-weight: 700; color: var(--color-slate); }
        
        /* Rest Overlay */
        .rest-overlay { background: linear-gradient(135deg, rgba(168, 201, 155, 0.95), rgba(135, 168, 120, 0.95)); }
        .rest-timer { font-size: 4.5rem; font-weight: 800; color: white; text-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .rest-message { font-size: 1.2rem; color: white; margin-top: 12px; opacity: 0.9; }
        
        /* Complete Overlay */
        .summary-card { background: white; border: 1px solid #e8e4df; border-radius: 20px; padding: 24px; margin-bottom: 20px; }
        .summary-stat { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #f0ece6; }
        .summary-stat:last-child { border-bottom: none; }
        .summary-label { color: var(--color-slate-light); font-weight: 500; }
        .summary-value { color: var(--color-slate); font-weight: 700; }
        .grade-badge { display: inline-block; padding: 6px 16px; border-radius: 10px; font-weight: 800; font-size: 1rem; }
        .grade-a { background: #d4edda; color: #155724; }
        .grade-b { background: #fff3cd; color: #856404; }
        .grade-c { background: #ffe0b2; color: #e65100; }
        .complete-buttons { display: flex; flex-direction: column; gap: 12px; margin-top: 24px; }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content { background: white; border-radius: 24px; padding: 32px; max-width: 400px; width: 90%; text-align: center; }
        .modal-title { font-size: 1.3rem; font-weight: 800; color: var(--color-slate); margin-bottom: 12px; }
        .modal-desc { color: var(--color-slate-light); margin-bottom: 24px; }
        .modal-buttons { display: flex; gap: 12px; justify-content: center; }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
        }
    </style>
</head>
<body>
    <!-- Floating Controls -->
    <button id="btn-home" class="float-btn hidden" aria-label="Go home" title="Go Home">üè†</button>
    <button id="btn-audio" class="float-btn hidden" aria-label="Toggle audio" title="Toggle Audio">üîä</button>
    <button id="btn-skip" class="float-btn hidden" aria-label="Skip exercise" title="Skip">‚è≠Ô∏è</button>
    <button id="btn-ibe" class="float-btn" aria-label="Toggle InvisibleBoundaryEngine" title="Toggle InvisibleBoundaryEngine">IBE</button>
    <button id="toggleBoundaryViz" class="float-btn" aria-label="Toggle Boundary Visualizer" title="Toggle Boundary Visualization" style="right: 20px;">üîç</button>

    <!-- Toast Notification -->
    <div id="toast" class="toast">
        <span class="toast-icon">‚úÖ</span>
        <span class="toast-message" id="toast-message">Session saved!</span>
    </div>

    <!-- Main Container -->
    <div id="app-container">
        <video id="video-bg" playsinline muted autoplay></video>
        <div id="portal-wrapper">
            <div id="portal-frame">
                <div id="portal-view">
                    <video id="video-clean" playsinline muted autoplay></video>
                    <canvas id="output-canvas"></canvas>
                    
                    <!-- Low Light Warning -->
                    <div class="low-light-warning" id="low-light-warning">
                        üí° Low light detected - move to a brighter area
                    </div>
                    
                    <div id="hud-layer">
                        <div class="top-row">
                            <div class="glass-pill progress-pill">
                                <span id="exercise-progress">1 of 8</span>
                            </div>
                            <div class="glass-pill instruction-banner">
                                <span class="instruction-icon" id="instruction-icon">üëã</span>
                                <div>
                                    <div class="instruction-text" id="instruction-text">Get Ready</div>
                                    <div class="instruction-sub" id="instruction-sub">Position hand in frame</div>
                                    <div class="phase-indicator" id="phase-indicator">
                                        <div class="phase-dot" id="phase-dot-1"></div>
                                        <div class="phase-dot" id="phase-dot-2"></div>
                                        <span class="phase-label" id="phase-label">Step 1: Reset</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Color indicator instead of accuracy percentage -->
                            <div class="glass-pill accuracy-indicator">
                                <div class="zone-dot" id="zone-indicator"></div>
                                <span class="zone-label">Status</span>
                            </div>
                        </div>

                        <div class="center-feedback">
                            <div id="hold-timer">3</div>
                            <div id="feedback-message">Nice!</div>
                        </div>
                        
                        <div id="reset-instruction">
                            <div class="reset-icon">‚úä</div>
                            <div class="reset-text" id="reset-text">Make a fist to begin</div>
                        </div>

                        <div class="stats-bar">
                            <div class="glass-pill stat-card" id="streak-card">
                                <span>üî•</span>
                                <div><div id="stat-streak" class="stat-val">0</div><div class="stat-label">Streak</div></div>
                            </div>
                            <div class="glass-pill stat-card">
                                <span>‚ú®</span>
                                <div><div id="stat-completed" class="stat-val">0</div><div class="stat-label">Done</div></div>
                            </div>
                            <div class="glass-pill progress-pill">
                                <span id="session-timer">0:00</span>
                            </div>
                        </div>
                    </div>

                    <div id="progress-bar-container">
                        <div id="progress-bar-fill"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- OVERLAY: Onboarding -->
    <div id="overlay-welcome" class="overlay-screen">
        <div class="overlay-content">
            <div class="onboarding-step active" data-step="1">
                <div class="onboarding-image">üå±</div>
                <h1 class="onboarding-title">Welcome to HandHero</h1>
                <p class="onboarding-desc">Your personal hand therapy companion with real-time visual feedback to guide your rehabilitation journey.</p>
                <div class="onboarding-dots"><div class="onboarding-dot active"></div><div class="onboarding-dot"></div><div class="onboarding-dot"></div><div class="onboarding-dot"></div></div>
                <button class="btn btn-primary" onclick="nextStep()">Get Started</button>
            </div>
            <div class="onboarding-step" data-step="2">
                <div class="onboarding-image">üéØ</div>
                <h2 class="onboarding-title">Visual Accuracy Zones</h2>
                <p class="onboarding-desc">
                    Watch the <strong>color indicator</strong> on screen:<br><br>
                    <span style="color: var(--zone-green-solid);">üü¢ Green</span> = Perfect! You're in the target zone<br>
                    <span style="color: var(--zone-blue-solid);">üîµ Blue</span> = Good! Almost there<br>
                    <span style="color: var(--zone-yellow-solid);">üü° Yellow</span> = Keep adjusting<br><br>
                    Work at YOUR comfortable pace!
                </p>
                <div class="onboarding-dots"><div class="onboarding-dot"></div><div class="onboarding-dot active"></div><div class="onboarding-dot"></div><div class="onboarding-dot"></div></div>
                <button class="btn btn-primary" onclick="nextStep()">Next</button>
                <button class="btn btn-ghost" onclick="prevStep()">Back</button>
            </div>
            <div class="onboarding-step" data-step="3">
                <div class="onboarding-image">‚úä</div>
                <h2 class="onboarding-title">Two-Step Exercises</h2>
                <p class="onboarding-desc">
                    Each exercise has two steps:<br><br>
                    <strong>Step 1:</strong> Make a fist to reset<br>
                    <strong>Step 2:</strong> Extend ONLY the required finger(s)<br><br>
                    This ensures proper isolation and form.
                </p>
                <div class="onboarding-dots"><div class="onboarding-dot"></div><div class="onboarding-dot"></div><div class="onboarding-dot active"></div><div class="onboarding-dot"></div></div>
                <button class="btn btn-primary" onclick="nextStep()">Next</button>
                <button class="btn btn-ghost" onclick="prevStep()">Back</button>
            </div>
            <div class="onboarding-step" data-step="4">
                <div class="onboarding-image">‚öïÔ∏è</div>
                <h2 class="onboarding-title">Safety First</h2>
                <div class="disclaimer-box">
                    <h4>Medical Disclaimer</h4>
                    <p>HandHero is a wellness tool to supplement ‚Äì not replace ‚Äì professional care.</p>
                    <ul>
                        <li>NOT a medical device</li>
                        <li>Does NOT provide diagnosis</li>
                        <li>Should NOT replace therapy</li>
                    </ul>
                    <p><strong>Stop if you experience:</strong> pain, numbness, tingling, swelling.</p>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="disclaimer-check">
                    <label for="disclaimer-check">I understand this is a wellness tool and will stop if I feel pain.</label>
                </div>
                <div class="onboarding-dots"><div class="onboarding-dot"></div><div class="onboarding-dot"></div><div class="onboarding-dot"></div><div class="onboarding-dot active"></div></div>
                <button class="btn btn-primary" id="btn-start" disabled onclick="startApp()">I Understand ‚Äì Begin</button>
                <button class="btn btn-ghost" onclick="prevStep()">Back</button>
            </div>
        </div>
    </div>

    <!-- OVERLAY: Ready (Between Exercises) -->
    <div id="overlay-ready" class="overlay-screen ready-overlay hidden">
        <div class="overlay-content">
            <p style="color: white; font-size: 1.1rem; margin-bottom: 8px; opacity: 0.8;">Next Exercise</p>
            <div class="ready-countdown" id="ready-countdown">3</div>
            <div class="ready-exercise-preview">
                <span class="ready-exercise-icon" id="ready-icon">‚úã</span>
                <div style="text-align: left;">
                    <div class="ready-exercise-name" id="ready-name">Starfish</div>
                    <div class="ready-exercise-desc" id="ready-desc">Spread all fingers wide</div>
                </div>
            </div>
            <p style="color: white; font-size: 0.9rem; margin-top: 24px; opacity: 0.7;">Get ready to make a fist first...</p>
        </div>
    </div>

    <!-- OVERLAY: Pain Check -->
    <div id="overlay-pain" class="overlay-screen hidden">
        <div class="overlay-content">
            <div class="onboarding-image">üíö</div>
            <h2 class="onboarding-title">Quick Check-In</h2>
            <p class="onboarding-desc">How is your hand feeling?</p>
            <div class="pain-scale">
                <button class="pain-btn green" onclick="selectPain(0)"><span class="pain-emoji">üòä</span><span class="pain-label">Great</span></button>
                <button class="pain-btn yellow" onclick="selectPain(1)"><span class="pain-emoji">üòê</span><span class="pain-label">Mild</span></button>
                <button class="pain-btn orange" onclick="selectPain(2)"><span class="pain-emoji">üòï</span><span class="pain-label">Moderate</span></button>
                <button class="pain-btn red" onclick="selectPain(3)"><span class="pain-emoji">üò£</span><span class="pain-label">Too Much</span></button>
            </div>
            <p id="pain-advice" style="font-size: 0.9rem; color: var(--color-slate-light); min-height: 40px;"></p>
            <button class="btn btn-primary" id="btn-continue-pain" disabled onclick="continuePain()">Continue</button>
        </div>
    </div>

    <!-- OVERLAY: Rest -->
    <div id="overlay-rest" class="overlay-screen rest-overlay hidden">
        <div class="overlay-content">
            <h2 class="onboarding-title" style="color: white;">Quick Break</h2>
            <div class="rest-timer" id="rest-timer">3</div>
            <p class="rest-message">Shake out your hand, take a breath</p>
            <button class="btn btn-secondary" onclick="skipRest()" style="margin-top: 20px;">I'm Ready</button>
        </div>
    </div>

    <!-- OVERLAY: Complete -->
    <div id="overlay-complete" class="overlay-screen hidden">
        <div class="overlay-content">
            <div class="onboarding-image">üéâ</div>
            <h2 class="onboarding-title">Session Complete!</h2>
            <div class="summary-card">
                <div class="summary-stat"><span class="summary-label">Exercises</span><span class="summary-value" id="sum-done">8</span></div>
                <div class="summary-stat"><span class="summary-label">Duration</span><span class="summary-value" id="sum-time">4:30</span></div>
                <div class="summary-stat"><span class="summary-label">Best Streak</span><span class="summary-value" id="sum-streak">5 üî•</span></div>
                <div class="summary-stat"><span class="summary-label">Avg Accuracy</span><span class="summary-value" id="sum-accuracy">78%</span></div>
                <div class="summary-stat"><span class="summary-label">Grade</span><span class="summary-value"><span id="sum-grade" class="grade-badge grade-a">A</span></span></div>
            </div>
            <div class="complete-buttons">
                <button class="btn btn-primary" onclick="goHome()">üè† Back to Dashboard</button>
                <button class="btn btn-secondary" onclick="confirmRestart()">üîÑ New Session</button>
                <button class="btn btn-ghost" onclick="exportReport()">üìÑ Save Report</button>
            </div>
        </div>
    </div>

    <!-- OVERLAY: Loading -->
    <div id="overlay-loading" class="overlay-screen hidden">
        <div class="overlay-content">
            <div class="onboarding-image" style="animation: pulse-scale 1.5s infinite;">üñêÔ∏è</div>
            <h2 class="onboarding-title">Preparing Session</h2>
            <p class="onboarding-desc" id="loading-msg">Loading hand tracking...</p>
        </div>
    </div>

    <!-- Skip Suggestion Modal -->
    <div id="modal-skip-suggest" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title">Having Trouble?</h3>
            <p class="modal-desc">This exercise seems challenging. Would you like to skip it and try another?</p>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeSkipModal()">Keep Trying</button>
                <button class="btn btn-primary" onclick="confirmSkipFromModal()">Skip Exercise</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="modal-confirm" class="modal-overlay">
        <div class="modal-content">
            <h3 class="modal-title" id="modal-title">Restart Session?</h3>
            <p class="modal-desc" id="modal-desc">Your current progress will be saved. Start a new session?</p>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" id="modal-confirm-btn" onclick="confirmModalAction()">Confirm</button>
            </div>
        </div>
    </div>

    <script src="Handheroexercises.js"></script>

    <script>
// ============================================
// DEBUG FLAG (set to true to see boundary lines)
// ============================================
const DEBUG = false;

// ============================================
// CONFIGURATION
// ============================================
const CONFIG = {
    EXERCISES_PER_SESSION: 8,
    REST_SECONDS: 3,  // Shortened from 8
    PAIN_CHECK_EVERY: 4,
    READY_COUNTDOWN_SECONDS: 3,  // Ready gate
    READY_TRACKING_DELAY_MS: 2000,  // 2 second delay before tracking counts
    
    // Accuracy thresholds for zones
    ZONE_GREEN: 0.85,
    ZONE_BLUE: 0.65,
    ZONE_YELLOW: 0.40,
    
    // Hold duration
    HOLD_DURATION_MS: 2500,
    
    // Reset detection
    RESET_CURL_THRESHOLD: 0.45,
    RESET_HOLD_MS: 500,
    
    // Soft decay rate (instead of hard reset)
    SOFT_DECAY_RATE: 0.015,
    // Skeleton smoothing (0-0.95). Higher = smoother but more lag.
    SKELETON_SMOOTHING: 0.6,
    
    // Skip suggestion triggers
    SKIP_SUGGEST_AFTER_SECONDS: 10,
    SKIP_SUGGEST_AFTER_FLICKERS: 15,
    
    // Low light detection
    LOW_LIGHT_THRESHOLD: 50,
};

// ============================================
// BOUNDARY ENGINE (Embedded)
// ============================================
const BoundaryEngine = {
    FINGER_TIPS: [4, 8, 12, 16, 20],
    FINGER_BASES: [1, 5, 9, 13, 17],
    
    getHandFrame(lm) {
        const wrist = lm[0];
        const middleTip = lm[12];
        const indexBase = lm[5];
        const pinkyBase = lm[17];
        
        const handHeight = Math.hypot(
            middleTip.x - wrist.x,
            middleTip.y - wrist.y,
            (middleTip.z || 0) - (wrist.z || 0)
        );
        
        const handWidth = Math.hypot(
            pinkyBase.x - indexBase.x,
            pinkyBase.y - indexBase.y
        );
        
        const palmCenter = {
            x: (lm[0].x + lm[5].x + lm[9].x + lm[13].x + lm[17].x) / 5,
            y: (lm[0].y + lm[5].y + lm[9].y + lm[13].y + lm[17].y) / 5
        };
        
        return { handHeight, handWidth, palmCenter, wrist };
    },
    
    checkFingerExtended(fingerIdx, lm, frame) {
        const tipIdx = this.FINGER_TIPS[fingerIdx];
        const baseIdx = this.FINGER_BASES[fingerIdx];
        
        const tip = lm[tipIdx];
        const base = lm[baseIdx];
        const wrist = lm[0];
        
        const tipAboveBase = base.y - tip.y;
        const normalized = tipAboveBase / frame.handHeight;
        
        const tipToWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const baseToWrist = Math.hypot(base.x - wrist.x, base.y - wrist.y);
        const ratio = tipToWrist / baseToWrist;
        
        if (normalized > 0.06 && ratio > 1.1) return { zone: 'GREEN', score: 1.0 };
        if (normalized > 0.02 && ratio > 1.0) return { zone: 'BLUE', score: 0.80 };
        if (normalized > -0.03 && ratio > 0.9) return { zone: 'YELLOW', score: 0.60 };
        return { zone: 'RED', score: Math.max(0.2, 0.5 + normalized) };
    },
    
    checkFingerCurled(fingerIdx, lm, frame) {
        const tipIdx = this.FINGER_TIPS[fingerIdx];
        const baseIdx = this.FINGER_BASES[fingerIdx];
        
        const tip = lm[tipIdx];
        const base = lm[baseIdx];
        
        const tipBelowBase = tip.y - base.y;
        const normalized = tipBelowBase / frame.handHeight;
        
        if (normalized >= 0.12) return { zone: 'GREEN', score: 1.0 };
        if (normalized >= 0.04) return { zone: 'YELLOW', score: 0.70 };
        if (normalized >= 0) return { zone: 'ORANGE', score: 0.50 };
        return { zone: 'RED', score: Math.max(0.15, 0.40 + normalized) };
    },
    
    evaluateIsolation(lm, targetFingers) {
        const frame = this.getHandFrame(lm);
        const results = [];
        let totalScore = 0;
        let nonTargetViolation = false;
        
        for (let i = 0; i < 5; i++) {
            const isTarget = targetFingers.includes(i);
            let result;
            
            if (isTarget) {
                result = this.checkFingerExtended(i, lm, frame);
            } else {
                result = this.checkFingerCurled(i, lm, frame);
                // Yellow is acceptable for non-targets, only RED is a violation
                // Thumb (index 0) is more lenient
                if (i === 0) {
                    // Thumb is lenient - only hard violations fail
                    if (result.zone === 'RED' && result.score < 0.3) {
                        nonTargetViolation = true;
                    }
                } else if (result.zone === 'RED') {
                    nonTargetViolation = true;
                }
            }
            
            result.isTarget = isTarget;
            results.push(result);
            totalScore += result.score;
        }
        
        const accuracy = totalScore / 5;
        let zone = 'RED';
        if (accuracy >= 0.85) zone = 'GREEN';
        else if (accuracy >= 0.65) zone = 'BLUE';
        else if (accuracy >= 0.45) zone = 'YELLOW';
        
        return { 
            accuracy, 
            zone, 
            results, 
            frame, 
            passed: accuracy >= 0.65 && !nonTargetViolation,
            nonTargetViolation
        };
    },
    
    evaluatePinch(lm, pinchPair) {
        const frame = this.getHandFrame(lm);
        const [p1, p2] = pinchPair;
        
        const tip1 = lm[p1];
        const tip2 = lm[p2];
        
        const distance = Math.hypot(
            tip1.x - tip2.x,
            tip1.y - tip2.y,
            (tip1.z || 0) - (tip2.z || 0)
        );
        
        const normalized = distance / frame.handWidth;
        
        let accuracy, zone;
        if (normalized < 0.08) { accuracy = 1.0; zone = 'GREEN'; }
        else if (normalized < 0.12) { accuracy = 0.85; zone = 'BLUE'; }
        else if (normalized < 0.18) { accuracy = 0.65; zone = 'YELLOW'; }
        else if (normalized < 0.25) { accuracy = 0.45; zone = 'ORANGE'; }
        else { accuracy = 0.25; zone = 'RED'; }
        
        // Check non-target fingers are relaxed (not interfering)
        let nonTargetOk = true;
        const involvedFingers = [];
        if (p1 === 4) involvedFingers.push(0); // thumb
        if (p2 === 8) involvedFingers.push(1);
        if (p2 === 12) involvedFingers.push(2);
        if (p2 === 16) involvedFingers.push(3);
        if (p2 === 20) involvedFingers.push(4);
        
        for (let i = 0; i < 5; i++) {
            if (involvedFingers.includes(i)) continue;
            const result = this.checkFingerCurled(i, lm, frame);
            // Yellow is OK, only RED fails
            if (result.zone === 'RED' && result.score < 0.4) {
                nonTargetOk = false;
            }
        }
        
        return {
            accuracy,
            zone,
            frame,
            distance: normalized,
            passed: accuracy >= 0.65 && nonTargetOk,
            nonTargetOk
        };
    },
    
    evaluateSpread(lm) {
        const frame = this.getHandFrame(lm);
        const tips = this.FINGER_TIPS.map(i => lm[i]);
        
        let extScore = 0;
        const results = [];
        for (let i = 0; i < 5; i++) {
            const r = this.checkFingerExtended(i, lm, frame);
            r.isTarget = true;
            results.push(r);
            extScore += r.score;
        }
        extScore /= 5;
        
        let gapScore = 0;
        const gaps = [];
        for (let i = 0; i < 4; i++) {
            const gap = Math.hypot(tips[i+1].x - tips[i].x, tips[i+1].y - tips[i].y);
            const norm = gap / frame.handWidth;
            gaps.push(norm);
            if (norm > 0.20) gapScore += 1.0;
            else if (norm > 0.12) gapScore += 0.75;
            else if (norm > 0.06) gapScore += 0.50;
            else gapScore += 0.25;
        }
        gapScore /= 4;
        
        const accuracy = (extScore * 0.5) + (gapScore * 0.5);
        let zone = 'RED';
        if (accuracy >= 0.85) zone = 'GREEN';
        else if (accuracy >= 0.65) zone = 'BLUE';
        else if (accuracy >= 0.45) zone = 'YELLOW';
        
        return { accuracy, zone, results, frame, gaps, passed: accuracy >= 0.65 };
    },
    
    evaluateFist(lm) {
        const frame = this.getHandFrame(lm);
        let score = 0;
        
        for (let i = 0; i < 5; i++) {
            const result = this.checkFingerCurled(i, lm, frame);
            score += result.score;
        }
        
        const accuracy = score / 5;
        let zone = 'RED';
        if (accuracy >= 0.85) zone = 'GREEN';
        else if (accuracy >= 0.65) zone = 'BLUE';
        else if (accuracy >= 0.45) zone = 'YELLOW';
        
        return { accuracy, zone, frame, passed: accuracy >= 0.60 };
    }
};

// ============================================
// FINGER CONSTANTS
// ============================================
const FINGER = {
    THUMB: [1, 2, 3, 4],
    INDEX: [5, 6, 7, 8],
    MIDDLE: [9, 10, 11, 12],
    RING: [13, 14, 15, 16],
    PINKY: [17, 18, 19, 20]
};
const FINGER_ARRAYS = [FINGER.THUMB, FINGER.INDEX, FINGER.MIDDLE, FINGER.RING, FINGER.PINKY];
const FINGER_NAMES = ['Thumb', 'Index', 'Middle', 'Ring', 'Pinky'];
const FINGER_TIPS = [4, 8, 12, 16, 20];

// ============================================
// EXERCISE LIBRARY
// ============================================
const ALL_EXERCISES = [
    { id: 'thumbs_up', name: 'Thumbs Up', icon: 'üëç', category: 'Isolation', desc: 'Extend only your thumb', difficulty: 2, type: 'isolation', targetFingers: [0] },
    { id: 'pointer', name: 'Pointer Finger', icon: '‚òùÔ∏è', category: 'Isolation', desc: 'Extend only your index finger', difficulty: 2, type: 'isolation', targetFingers: [1] },
    { id: 'middle_finger_lift', name: 'Middle Finger Lift', icon: 'üñï', category: 'Isolation', desc: 'Extend only your middle finger', difficulty: 3, type: 'isolation', targetFingers: [2] },
    { id: 'ring_finger_lift', name: 'Ring Finger Lift', icon: 'üíç', category: 'Advanced', desc: 'Extend only your ring finger (hardest!)', difficulty: 4, type: 'isolation', targetFingers: [3] },
    { id: 'pinky_out', name: 'Pinky Extension', icon: 'ü§ô', category: 'Isolation', desc: 'Extend only your pinky finger', difficulty: 3, type: 'isolation', targetFingers: [4] },
    { id: 'peace', name: 'Peace Sign', icon: '‚úåÔ∏è', category: 'Coordination', desc: 'Extend index and middle fingers only', difficulty: 2, type: 'isolation', targetFingers: [1, 2] },
    { id: 'rock_on', name: 'Rock On', icon: 'ü§ò', category: 'Advanced', desc: 'Extend index and pinky only', difficulty: 4, type: 'isolation', targetFingers: [1, 4] },
    { id: 'ok_sign', name: 'OK Sign', icon: 'üëå', category: 'Precision', desc: 'Touch thumb tip to index tip', difficulty: 2, type: 'pinch', pinchPair: [4, 8] },
    { id: 'thumb_to_middle', name: 'Thumb to Middle', icon: 'ü§å', category: 'Precision', desc: 'Touch thumb tip to middle fingertip', difficulty: 2, type: 'pinch', pinchPair: [4, 12] },
    { id: 'thumb_to_ring', name: 'Thumb to Ring', icon: 'ü§è', category: 'Precision', desc: 'Touch thumb tip to ring fingertip', difficulty: 3, type: 'pinch', pinchPair: [4, 16] },
    { id: 'thumb_to_pinky', name: 'Thumb to Pinky', icon: 'ü§ô', category: 'Precision', desc: 'Touch thumb tip to pinky tip', difficulty: 3, type: 'pinch', pinchPair: [4, 20] },
    { id: 'starfish', name: 'Starfish Spread', icon: 'üñêÔ∏è', category: 'Stretch', desc: 'Spread all fingers as wide as possible', difficulty: 1, type: 'spread' },
    { id: 'flat_hand', name: 'Flat Hand', icon: 'ü§ö', category: 'Stretch', desc: 'Fingers together, fully extended', difficulty: 1, type: 'flat' },
    { id: 'fist', name: 'Gentle Fist', icon: '‚úä', category: 'Strength', desc: 'Curl all fingers into a fist', difficulty: 1, type: 'fist' },
];

function selectExercises() {
    // Prefer using HandHeroExercises module when available
    if (typeof window !== 'undefined' && window.HandHeroExercises && typeof HandHeroExercises.buildSession === 'function') {
        try {
            return HandHeroExercises.buildSession(CONFIG.EXERCISES_PER_SESSION || 8);
        } catch (e) {
            console.warn('HandHeroExercises.buildSession failed, falling back to local library', e);
        }
    }

    const shuffle = a => [...a].sort(() => Math.random() - 0.5);
    const byDiff = d => ALL_EXERCISES.filter(e => e.difficulty === d);
    const selected = [
        ...shuffle(byDiff(1)).slice(0, 2),
        ...shuffle(byDiff(2)).slice(0, 3),
        ...shuffle(byDiff(3)).slice(0, 2),
        ...shuffle(byDiff(4)).slice(0, 1),
    ];
    return shuffle(selected);
}

// ============================================
// STATE
// ============================================
const state = {
    step: 1,
    screen: 'WELCOME',
    handLandmarker: null,
    webcamRunning: false,
    animationFrameId: null,
    
    exercises: [],
    exIdx: 0,
    completed: 0,
    streak: 0,
    bestStreak: 0,
    startTime: 0,
    
    phase: 'RESET',
    resetStartTime: 0,
    resetComplete: false,
    
    holding: false,
    holdStart: 0,
    progress: 0,
    cooldown: false,
    currentAcc: 0,
    peakAcc: 0,
    
    landmarks: null,
    // Smoothed landmarks for rendering + stable scoring
    smoothedLandmarks: null,
    
    // Ready gate tracking
    readyGateActive: false,
    readyGateEndTime: 0,
    
    // Skip suggestion tracking
    exerciseStartTime: 0,
    flickerCount: 0,
    lastLandmarkState: null,
    skipSuggestionShown: false,
    
    // Low light tracking
    lowLightDetected: false,
    brightnessHistory: [],
    
    painLevels: [],
    selectedPain: null,
    log: [],
    
    animTime: 0,
    modalAction: null,
    // InvisibleBoundaryEngine toggle
    invisibleEnabled: true,
};

// ============================================
// DOM REFERENCES
// ============================================
const $ = id => document.getElementById(id);
const el = {
    welcome: $('overlay-welcome'),
    loading: $('overlay-loading'),
    ready: $('overlay-ready'),
    pain: $('overlay-pain'),
    rest: $('overlay-rest'),
    complete: $('overlay-complete'),
    
    videoBg: $('video-bg'),
    video: $('video-clean'),
    canvas: $('output-canvas'),
    frame: $('portal-frame'),
    view: $('portal-view'),
    
    btnHome: $('btn-home'),
    btnAudio: $('btn-audio'),
    btnSkip: $('btn-skip'),
    btnIbe: $('btn-ibe'),
    
    icon: $('instruction-icon'),
    text: $('instruction-text'),
    sub: $('instruction-sub'),
    progress: $('exercise-progress'),
    timer: $('session-timer'),
    
    zoneIndicator: $('zone-indicator'),
    
    phaseDot1: $('phase-dot-1'),
    phaseDot2: $('phase-dot-2'),
    phaseLabel: $('phase-label'),
    
    streak: $('stat-streak'),
    done: $('stat-completed'),
    
    holdTimer: $('hold-timer'),
    feedback: $('feedback-message'),
    bar: $('progress-bar-fill'),
    
    resetInstruction: $('reset-instruction'),
    resetText: $('reset-text'),
    
    readyCountdown: $('ready-countdown'),
    readyIcon: $('ready-icon'),
    readyName: $('ready-name'),
    readyDesc: $('ready-desc'),
    
    restTimer: $('rest-timer'),
    painAdvice: $('pain-advice'),
    btnContinuePain: $('btn-continue-pain'),
    
    sumDone: $('sum-done'),
    sumTime: $('sum-time'),
    sumStreak: $('sum-streak'),
    sumAccuracy: $('sum-accuracy'),
    sumGrade: $('sum-grade'),
    
    loadMsg: $('loading-msg'),
    disclaimerCheck: $('disclaimer-check'),
    btnStart: $('btn-start'),
    
    toast: $('toast'),
    toastMessage: $('toast-message'),
    
    modal: $('modal-confirm'),
    modalTitle: $('modal-title'),
    modalDesc: $('modal-desc'),
    
    modalSkip: $('modal-skip-suggest'),
    lowLightWarning: $('low-light-warning'),
};

const ctx = el.canvas.getContext('2d');
let audioCtx = null;

// Initialize IBE toggle button
function updateIbeButton() {
    if (!el.btnIbe) return;
    el.btnIbe.classList.toggle('active', !!state.invisibleEnabled);
    el.btnIbe.textContent = state.invisibleEnabled ? 'IBE ON' : 'IBE OFF';
}

if (el.btnIbe) {
    el.btnIbe.addEventListener('click', () => {
        state.invisibleEnabled = !state.invisibleEnabled;
        updateIbeButton();
        const msg = state.invisibleEnabled ? 'InvisibleBoundaryEngine enabled' : 'InvisibleBoundaryEngine disabled';
        el.toast.querySelector('.toast-message').textContent = msg;
        el.toast.querySelector('.toast-icon').textContent = state.invisibleEnabled ? 'üü¢' : '‚ö™';
        el.toast.classList.add('show');
        setTimeout(() => el.toast.classList.remove('show'), 1800);
    });
}

updateIbeButton();

// Initialize BoundaryVisualizer toggle button
const boundaryToggleBtn = document.getElementById('toggleBoundaryViz');
if (boundaryToggleBtn && typeof BoundaryVisualizer !== 'undefined') {
    boundaryToggleBtn.addEventListener('click', () => {
        const isEnabled = BoundaryVisualizer.toggle();
        boundaryToggleBtn.classList.toggle('active', isEnabled);
        boundaryToggleBtn.textContent = isEnabled ? 'üîç' : 'üîç';
        const msg = isEnabled ? 'Boundary Visualizer enabled' : 'Boundary Visualizer disabled';
        el.toast.querySelector('.toast-message').textContent = msg;
        el.toast.querySelector('.toast-icon').textContent = isEnabled ? 'üü¢' : '‚ö™';
        el.toast.classList.add('show');
        setTimeout(() => el.toast.classList.remove('show'), 1800);
    });
}

// ============================================
// TOAST NOTIFICATION
// ============================================
function showToast(message, icon = '‚úÖ') {
    el.toastMessage.textContent = message;
    el.toast.querySelector('.toast-icon').textContent = icon;
    el.toast.classList.add('show');
    setTimeout(() => el.toast.classList.remove('show'), 3000);
}

// ============================================
// ONBOARDING
// ============================================
function nextStep() {
    state.step++;
    updateStepUI();
}

function prevStep() {
    state.step--;
    updateStepUI();
}

function updateStepUI() {
  // Activate the correct step panel
  document.querySelectorAll('.onboarding-step').forEach((s, i) =>
    s.classList.toggle('active', i + 1 === state.step)
  );

  // IMPORTANT: only touch dots inside the ACTIVE step
  const activeStep = document.querySelector('.onboarding-step.active');
  if (!activeStep) return;

  // Reset dots in all steps so nothing "leaks" across panels
  document.querySelectorAll('.onboarding-step').forEach(stepEl => {
    stepEl.querySelectorAll('.onboarding-dot').forEach(d => {
      d.classList.remove('active', 'completed');
    });
  });

  const dots = Array.from(activeStep.querySelectorAll('.onboarding-dot'));
  const activeIndex = Math.max(0, Math.min(state.step - 1, dots.length - 1));

  dots.forEach((d, i) => {
    d.classList.toggle('active', i === activeIndex);
    d.classList.toggle('completed', i < activeIndex);
  });

  // Move pill to active dot
  setStepperPill(activeIndex);
}

function setStepperPill(stepIndex) {
  const stepper = document.querySelector('.onboarding-step.active .onboarding-dots');
  if (!stepper) return;

  let pill = stepper.querySelector('.pill');
  const isNewPill = !pill;

  if (!pill) {
    pill = document.createElement('div');
    pill.className = 'pill';
    stepper.appendChild(pill);
  }

  const dots = Array.from(stepper.querySelectorAll('.onboarding-dot'));
  if (dots.length === 0) return;

  dots.forEach((d, i) => d.classList.toggle('completed', i < stepIndex));

  const target = dots[Math.max(0, Math.min(stepIndex, dots.length - 1))];
  const stepperRect = stepper.getBoundingClientRect();
  const dotRect = target.getBoundingClientRect();

  // Measure pill width after insertion
  const pillRect = pill.getBoundingClientRect();
  const pillW = pillRect.width || 28;

  // Center pill over the dot
  const x = (dotRect.left - stepperRect.left) + (dotRect.width / 2) - (pillW / 2);
  const transformValue = `translate(${Math.round(x)}px, -50%)`;

  // Prevent the "jump" when switching steps (new dot row / new pill)
  if (isNewPill) {
    // Place it instantly at the correct position without animation
    const prevTransition = pill.style.transition;
    pill.style.transition = 'none';
    pill.style.transform = transformValue;

    // Re-enable CSS transition next frame so subsequent moves are smooth
    requestAnimationFrame(() => {
      pill.style.transition = prevTransition || '';
    });
    return;
  }

  // Normal smooth movement for existing pill
  pill.style.transform = transformValue;
}

window.addEventListener('load', () => requestAnimationFrame(() => setStepperPill(state.step - 1)));
window.addEventListener('resize', () => requestAnimationFrame(() => setStepperPill(state.step - 1)));

el.disclaimerCheck.addEventListener('change', e => {
    el.btnStart.disabled = !e.target.checked;
});

// ============================================
// INITIALIZATION
// ============================================
async function startApp() {
    if (!el.disclaimerCheck.checked) return;
    
    el.welcome.classList.add('hidden');
    el.loading.classList.remove('hidden');
    
    try {
        el.loadMsg.textContent = 'Loading AI model...';
        
        const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js");
        const fs = await vision.FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        
        state.handLandmarker = await vision.HandLandmarker.createFromOptions(fs, {
            baseOptions: {
                modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                delegate: 'GPU'
            },
            runningMode: 'VIDEO',
            numHands: 1
        });
        
        el.loadMsg.textContent = 'Starting camera...';
        
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720, facingMode: 'user' }
        });
        
        el.videoBg.srcObject = stream;
        el.video.srcObject = stream;
        
        await new Promise(resolve => { el.video.onloadeddata = resolve; });
        
        state.webcamRunning = true;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        el.loading.classList.add('hidden');
        showControls();
        beginSession();
        
    } catch (e) {
        console.error('Init error:', e);
        el.loadMsg.textContent = 'Error: ' + e.message;
    }
}

function showControls() {
    el.btnHome.classList.remove('hidden');
    el.btnAudio.classList.remove('hidden');
    el.btnSkip.classList.remove('hidden');
}

function hideControls() {
    el.btnHome.classList.add('hidden');
    el.btnAudio.classList.add('hidden');
    el.btnSkip.classList.add('hidden');
}

// ============================================
// SESSION MANAGEMENT
// ============================================
function beginSession() {
    // Full reset for new session
    state.exercises = selectExercises();
    state.exIdx = 0;
    state.completed = 0;
    state.streak = 0;
    state.bestStreak = 0;
    state.startTime = Date.now();
    state.log = [];
    state.painLevels = [];
    state.progress = 0;
    
    showReadyScreen(0);
}

function showReadyScreen(exerciseIndex) {
    state.screen = 'READY';
    state.exIdx = exerciseIndex;
    state.readyGateActive = true;
    
    const ex = state.exercises[exerciseIndex];
    el.readyIcon.textContent = ex.icon;
    el.readyName.textContent = ex.name;
    el.readyDesc.textContent = ex.desc;
    
    el.frame.className = 'ready';
    el.ready.classList.remove('hidden');
    
    let count = CONFIG.READY_COUNTDOWN_SECONDS;
    el.readyCountdown.textContent = count;
    
    const countdownInterval = setInterval(() => {
        count--;
        el.readyCountdown.textContent = count;
        
        if (count <= 0) {
            clearInterval(countdownInterval);
            el.ready.classList.add('hidden');
            startExercise(exerciseIndex);
        }
    }, 1000);
    
    speak(`Next: ${ex.name}. ${ex.desc}. Make a fist to begin.`);
}

function startExercise(index) {
    state.screen = 'SESSION';
    state.exIdx = index;
    
    const ex = state.exercises[index];
    
    el.icon.textContent = ex.icon;
    el.text.textContent = ex.name;
    el.sub.textContent = ex.desc;
    el.progress.textContent = `${index + 1} of ${state.exercises.length}`;
    
    state.phase = 'RESET';
    state.resetComplete = false;
    state.resetStartTime = 0;
    
    state.holding = false;
    state.holdStart = 0;
    state.progress = 0;
    state.cooldown = false;
    state.currentAcc = 0;
    state.peakAcc = 0;
    
    // Skip suggestion tracking reset
    state.exerciseStartTime = Date.now();
    state.flickerCount = 0;
    state.skipSuggestionShown = false;
    
    // Ready gate - delay before tracking counts
    state.readyGateActive = true;
    state.readyGateEndTime = Date.now() + CONFIG.READY_TRACKING_DELAY_MS;
    
    updatePhaseUI();
    
    el.bar.style.width = '0%';
    el.frame.className = 'reset';
    
    el.resetInstruction.classList.add('show');
    el.resetText.textContent = 'Make a fist to begin';
    
    if (!state.animationFrameId) {
        gameLoop();
    }
}

function updatePhaseUI() {
    if (state.phase === 'RESET') {
        el.phaseDot1.classList.add('active');
        el.phaseDot1.classList.remove('complete');
        el.phaseDot2.classList.remove('active', 'complete');
        el.phaseLabel.textContent = 'Step 1: Make a fist';
    } else {
        el.phaseDot1.classList.remove('active');
        el.phaseDot1.classList.add('complete');
        el.phaseDot2.classList.add('active');
        el.phaseDot2.classList.remove('complete');
        
        const ex = state.exercises[state.exIdx];
        if (ex.targetFingers) {
            const names = ex.targetFingers.map(i => FINGER_NAMES[i]).join(' & ');
            el.phaseLabel.textContent = `Step 2: Extend ${names}`;
        } else {
            el.phaseLabel.textContent = 'Step 2: ' + ex.desc;
        }
    }
}

// ============================================
// GAME LOOP
// ============================================
function gameLoop() {
    if (!state.webcamRunning) return;
    
    state.animTime = Date.now() / 1000;
    
    // Always detect and render hand if webcam is running (for all screens)
    try {
        const results = state.handLandmarker.detectForVideo(el.video, performance.now());
        
        resizeCanvas();
        ctx.clearRect(0, 0, el.canvas.width, el.canvas.height);
        
        // Check for flickering (hand detection instability)
        const hasHand = results.landmarks && results.landmarks.length > 0;
        if (state.lastLandmarkState !== null && state.lastLandmarkState !== hasHand) {
            state.flickerCount++;
        }
        state.lastLandmarkState = hasHand;
        
        if (hasHand) {
            state.landmarks = results.landmarks[0];

            // Update smoothed landmarks for more stable visuals and scoring
            const newLm = state.landmarks;
                if (!state.smoothedLandmarks) {
                    state.smoothedLandmarks = newLm.map(p => ({ x: p.x, y: p.y, z: p.z || 0 }));
                } else {
                    const a = CONFIG.SKELETON_SMOOTHING;
                    for (let i = 0; i < newLm.length; i++) {
                        const p = newLm[i];
                        const s = state.smoothedLandmarks[i];
                        s.x = s.x * a + p.x * (1 - a);
                        s.y = s.y * a + p.y * (1 - a);
                        if (p.z !== undefined) s.z = (s.z || 0) * a + (p.z || 0) * (1 - a);
                    }
                }

                // Only process phase logic during SESSION
                if (state.screen === 'SESSION') {
                    // Low light detection
                    checkLowLight();
                    
                    // Check if ready gate has passed
                    const gateActive = Date.now() < state.readyGateEndTime;

                    if (state.phase === 'RESET') {
                        checkResetPhase();
                    } else if (!gateActive) {
                        updateExecutePhase();
                    }
                    
                    // Check for skip suggestion
                    checkSkipSuggestion();
                }

                renderVisuals(state.smoothedLandmarks || state.landmarks);
            } else {
                state.landmarks = null;
                if (state.screen === 'SESSION' && state.phase === 'EXECUTE') {
                    // Soft decay instead of hard reset
                    state.progress = Math.max(0, state.progress - CONFIG.SOFT_DECAY_RATE);
                    el.bar.style.width = (50 + state.progress * 50) + '%';
                }
                const zoneVal = (state.invisibleEnabled && typeof InvisibleBoundaryEngine !== 'undefined') ? InvisibleBoundaryEngine.ZONE.RED : 0;
                updateZoneIndicator(zoneVal);
            }
            
        } catch (e) {
            console.error('Hand detection error:', e);
        }
    
    updateTimer();
    state.animationFrameId = requestAnimationFrame(gameLoop);
}

function checkLowLight() {
    // Sample video brightness
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 64;
    tempCanvas.height = 64;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(el.video, 0, 0, 64, 64);
    
    try {
        const imageData = tempCtx.getImageData(0, 0, 64, 64);
        const data = imageData.data;
        let totalBrightness = 0;
        
        for (let i = 0; i < data.length; i += 4) {
            totalBrightness += (data[i] + data[i+1] + data[i+2]) / 3;
        }
        
        const avgBrightness = totalBrightness / (64 * 64);
        state.brightnessHistory.push(avgBrightness);
        if (state.brightnessHistory.length > 30) state.brightnessHistory.shift();
        
        const smoothedBrightness = state.brightnessHistory.reduce((a,b) => a+b, 0) / state.brightnessHistory.length;
        
        const isLowLight = smoothedBrightness < CONFIG.LOW_LIGHT_THRESHOLD;
        
        if (isLowLight !== state.lowLightDetected) {
            state.lowLightDetected = isLowLight;
            el.lowLightWarning.classList.toggle('show', isLowLight);
        }
    } catch (e) {}
}

function checkSkipSuggestion() {
    if (state.skipSuggestionShown || state.cooldown || state.phase !== 'EXECUTE') return;
    
    const elapsed = (Date.now() - state.exerciseStartTime) / 1000;
    
    // Only show after 10 seconds OR 15+ flickers
    if (elapsed >= CONFIG.SKIP_SUGGEST_AFTER_SECONDS || state.flickerCount >= CONFIG.SKIP_SUGGEST_AFTER_FLICKERS) {
        state.skipSuggestionShown = true;
        el.modalSkip.classList.add('show');
    }
}

function closeSkipModal() {
    el.modalSkip.classList.remove('show');
}

function confirmSkipFromModal() {
    el.modalSkip.classList.remove('show');
    skipExercise();
}

function updateTimer() {
    if (state.startTime) {
        const s = Math.floor((Date.now() - state.startTime) / 1000);
        el.timer.textContent = `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
    }
}

// ============================================
// RESET PHASE
// ============================================
let relaxedResetBuffer = [];
const RESET_BUFFER_SIZE = 6;
const MAX_RELAXED_FINGERS = 1;

function checkResetPhase() {
    const lm = state.smoothedLandmarks || state.landmarks;
    if (!lm) return;

    // Prefer InvisibleBoundaryEngine fist check if available
    let relaxedCurled = false;
    if (typeof InvisibleBoundaryEngine !== 'undefined' && typeof InvisibleBoundaryEngine.isValidFist === 'function') {
        relaxedCurled = InvisibleBoundaryEngine.isValidFist(lm);
    } else {
        const result = BoundaryEngine.evaluateFist(lm);
        relaxedCurled = result && result.accuracy >= 0.55;
    }
    
    relaxedResetBuffer.push(relaxedCurled);
    if (relaxedResetBuffer.length > RESET_BUFFER_SIZE) relaxedResetBuffer.shift();
    
    const stableRelaxed = relaxedResetBuffer.filter(Boolean).length >= Math.ceil(RESET_BUFFER_SIZE * 0.6);
    
    if (stableRelaxed) {
        if (state.resetStartTime === 0) state.resetStartTime = Date.now();
        
        const elapsed = Date.now() - state.resetStartTime;
        const progress = Math.min(1, elapsed / CONFIG.RESET_HOLD_MS);
        
        el.resetText.textContent = 'Loose fist detected';
        el.bar.style.width = (progress * 50) + '%';
        
        if (elapsed >= CONFIG.RESET_HOLD_MS) {
            state.phase = 'EXECUTE';
            state.resetComplete = true;
            state.resetStartTime = 0;
            relaxedResetBuffer = [];
            
            // Reset ready gate for execute phase
            state.readyGateEndTime = Date.now() + CONFIG.READY_TRACKING_DELAY_MS;
            
            el.resetInstruction.classList.remove('show');
            el.frame.className = '';
            updatePhaseUI();
            
            const ex = state.exercises[state.exIdx];
            if (ex.targetFingers) {
                const names = ex.targetFingers.map(i => FINGER_NAMES[i]).join(' and ');
                speak(`Good. Now extend ${names}.`);
            } else {
                speak(`Good. Now ${ex.desc}`);
            }
        }
    } else {
        state.resetStartTime = 0;
        el.resetText.textContent = 'Make a fist to begin';
        el.bar.style.width = '0%';
    }
    
    const ZONE = 
        (typeof InvisibleBoundaryEngine !== 'undefined' && InvisibleBoundaryEngine.ZONE)
            ? InvisibleBoundaryEngine.ZONE
            : null;
    updateZoneIndicator(stableRelaxed ? (ZONE ? ZONE.YELLOW : 0.5) : (ZONE ? ZONE.RED : 0));
}

// ============================================
// EXECUTE PHASE
// ============================================
function updateExecutePhase() {
    if (state.cooldown || !(state.smoothedLandmarks || state.landmarks)) return;
    
    const ex = state.exercises[state.exIdx];
    // Single call to evaluate the exercise using InvisibleBoundaryEngine
    const evalLm = state.smoothedLandmarks || state.landmarks;
    if (!evalLm) return;

    let result;
    const useIBE = state.invisibleEnabled && typeof InvisibleBoundaryEngine !== 'undefined' && typeof InvisibleBoundaryEngine.evaluate === 'function';
    if (useIBE) {
        result = InvisibleBoundaryEngine.evaluate(evalLm, ex);
    } else {
        // Fallback to BoundaryEngine evaluators and normalize shape
        let r;
        if (ex.type === 'isolation') r = BoundaryEngine.evaluateIsolation(evalLm, ex.targetFingers);
        else if (ex.type === 'pinch') r = BoundaryEngine.evaluatePinch(evalLm, ex.pinchPair);
        else if (ex.type === 'spread') r = BoundaryEngine.evaluateSpread(evalLm);
        else if (ex.type === 'fist') r = BoundaryEngine.evaluateFist(evalLm);
        else if (ex.type === 'flat') {
            r = BoundaryEngine.evaluateSpread(evalLm);
            const avgGap = r.gaps ? r.gaps.reduce((a,b) => a+b, 0) / r.gaps.length : 0;
            if (avgGap < 0.06) r.accuracy = Math.min(1, (r.accuracy || 0) + 0.2);
        } else {
            r = { accuracy: 0.5, passed: false };
        }
        result = { score: r.accuracy || 0, passed: !!r.passed, zone: r.accuracy || 0 };
    }
    
    // Update state
    state.currentAcc = result.score;
    state.lastEvaluation = result; // Store for BoundaryVisualizer
    if (result.score > state.peakAcc) state.peakAcc = result.score;
    
    // Update zone indicator
    updateZoneIndicator(result.zone);
    
    // Hold logic with soft decay
    if (result.passed) {
        if (!state.holding) {
            state.holding = true;
            state.holdStart = Date.now();
        }
        
        // Progress faster with higher accuracy
        const multiplier = 0.5 + result.score * 0.5;
        const holdTime = Date.now() - state.holdStart;
        state.progress = Math.min(1, (holdTime / CONFIG.HOLD_DURATION_MS) * multiplier);
        
        // Check for success
        if (state.progress >= 1 && result.score >= 0.65) {
            exerciseSuccess(result.score);
        }
    } else {
        state.holding = false;
        // Soft decay instead of hard reset
        state.progress = Math.max(0, state.progress - CONFIG.SOFT_DECAY_RATE);
    }
    
    // Update UI
    el.bar.style.width = (50 + state.progress * 50) + '%';
    
    // Frame color feedback
    if (state.progress >= 1) {
        el.frame.className = 'success';
    } else if (state.holding) {
        el.frame.className = 'holding';
    } else {
        el.frame.className = '';
    }
    
    // Timer display
    if (state.holding && state.progress < 1) {
        const remaining = Math.ceil((1 - state.progress) * (CONFIG.HOLD_DURATION_MS / 1000));
        el.holdTimer.textContent = remaining;
        el.holdTimer.classList.add('show');
    } else {
        el.holdTimer.classList.remove('show');
    }
}

function updateZoneIndicator(zoneOrAcc) {
    el.zoneIndicator.classList.remove('green', 'blue', 'yellow', 'red');
    // If a numeric accuracy was passed, map to zone thresholds
    if (typeof zoneOrAcc === 'number') {
        const acc = zoneOrAcc;
        if (acc >= CONFIG.ZONE_GREEN) el.zoneIndicator.classList.add('green');
        else if (acc >= CONFIG.ZONE_BLUE) el.zoneIndicator.classList.add('blue');
        else if (acc >= CONFIG.ZONE_YELLOW) el.zoneIndicator.classList.add('yellow');
        else el.zoneIndicator.classList.add('red');
        return;
    }

    // Otherwise assume an InvisibleBoundaryEngine.ZONE constant
    const { ZONE } = typeof InvisibleBoundaryEngine !== 'undefined' ? InvisibleBoundaryEngine : {};
    if (ZONE && zoneOrAcc === ZONE.GREEN) el.zoneIndicator.classList.add('green');
    else if (ZONE && zoneOrAcc === ZONE.BLUE) el.zoneIndicator.classList.add('blue');
    else if (ZONE && zoneOrAcc === ZONE.YELLOW) el.zoneIndicator.classList.add('yellow');
    else el.zoneIndicator.classList.add('red');
}

// ============================================
// EXERCISE SUCCESS
// ============================================
function exerciseSuccess(acc) {
    state.cooldown = true;
    state.completed++;
    state.streak++;
    if (state.streak > state.bestStreak) state.bestStreak = state.streak;
    
    const ex = state.exercises[state.exIdx];
    const pct = Math.round(acc * 100);
    let grade = pct >= 90 ? 'A' : pct >= 80 ? 'A-' : pct >= 70 ? 'B+' : pct >= 60 ? 'B' : 'B-';
    
    state.log.push({ id: ex.id, name: ex.name, accuracy: pct, grade });
    
    const msgs = acc >= 0.85 
        ? ['Perfect! üåü', 'Excellent!', 'Amazing!'] 
        : acc >= 0.70 
            ? ['Great job!', 'Nice work!', 'Well done!']
            : ['Good effort!', 'Keep going!', 'You did it!'];
    
    showFeedback(msgs[Math.floor(Math.random() * msgs.length)]);
    playSound();
    spawnParticles();
    
    el.done.textContent = state.completed;
    el.streak.textContent = state.streak;
    
    setTimeout(() => {
        const nextIdx = state.exIdx + 1;
        
        if (state.completed > 0 && state.completed % CONFIG.PAIN_CHECK_EVERY === 0 && nextIdx < state.exercises.length) {
            showPainCheck();
            return;
        }
        
        if (nextIdx >= state.exercises.length) {
            endSession();
            return;
        }
        
        showReadyScreen(nextIdx);
        state.cooldown = false;
    }, 1800);
}

function skipExercise() {
    if (state.cooldown || state.screen !== 'SESSION') return;
    
    const ex = state.exercises[state.exIdx];
    state.log.push({ id: ex.id, name: ex.name, accuracy: Math.round(state.peakAcc * 100), grade: 'SKIP', skipped: true });
    state.streak = 0;
    el.streak.textContent = '0';
    
    const nextIdx = state.exIdx + 1;
    if (nextIdx >= state.exercises.length) {
        endSession();
    } else {
        showReadyScreen(nextIdx);
    }
}

// ============================================
// VISUAL RENDERING (Neutral Skeleton)
// ============================================
function resizeCanvas() {
    if (el.canvas.width !== el.view.clientWidth) {
        el.canvas.width = el.view.clientWidth;
        el.canvas.height = el.view.clientHeight;
    }
}

function project(pt) {
    const w = el.canvas.width, h = el.canvas.height;
    const scale = Math.max(w / 1280, h / 720);
    const sw = 1280 * scale, sh = 720 * scale;
    return { x: (w - sw) / 2 + (1 - pt.x) * sw, y: (h - sh) / 2 + pt.y * sh };
}

function renderVisuals(lm) {
    if (!lm || !ctx) {
        if (!ctx) console.warn('Canvas context (ctx) not initialized');
        return;
    }
    
    const ex = state.exercises && state.exercises[state.exIdx] ? state.exercises[state.exIdx] : null;
    
    // Always render neutral skeleton
    renderNeutralSkeleton(lm, ex);
    // Draw per-finger targets (glow when selected)
    renderFingerTargets(lm, ex);
    
    // For spread exercises, show shaded zones
    if (ex.type === 'spread' && state.phase === 'EXECUTE') {
        renderSpreadZones(lm);
    }
    
    // InvisibleBoundaryEngine overlay (shows immediately when IBE is ON)
    if (state.invisibleEnabled && state.phase === 'EXECUTE') {
        renderIBEOverlay(lm, ex);
    }
    
    // === BOUNDARY VISUALIZER ===
    // Render boundary zones visualization (only draws if enabled)
    if (typeof BoundaryVisualizer !== 'undefined') {
        const targetFingers = ex?.targetFingers || [];
        BoundaryVisualizer.render(ctx, el.canvas, lm, targetFingers, state.lastEvaluation || null);
    }
}

function renderFingerTargets(lm, ex) {
    if (!lm) return;
    const fingerColors = ['#e8998d','#68c896','#64b4e6','#d4a574','#c9a8d9'];
    const tips = FINGER_TIPS.map(i => project(lm[i]));

    tips.forEach((pt, fi) => {
        const isPinch = ex && ex.type === 'pinch' && ex.pinchPair && ex.pinchPair.includes(FINGER_TIPS[fi]);
        const isTarget = ex && ((ex.targetFingers && ex.targetFingers.includes(fi)) || ex.type === 'spread' || isPinch);

        const base = fingerColors[fi] || '#cccccc';
        // ring
        ctx.beginPath();
        ctx.lineWidth = isTarget ? 4 : 2;
        ctx.strokeStyle = isTarget ? base : 'rgba(120,120,120,0.18)';
        ctx.shadowColor = isTarget ? base : 'transparent';
        ctx.shadowBlur = isTarget ? 18 : 0;
        ctx.globalAlpha = isTarget ? 1 : 0.7;
        ctx.arc(pt.x, pt.y, isTarget ? 22 : 12, 0, Math.PI * 2);
        ctx.stroke();

        // center dot
        ctx.beginPath();
        ctx.fillStyle = isTarget ? base : 'white';
        ctx.shadowBlur = 0;
        ctx.arc(pt.x, pt.y, isTarget ? 7 : 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });
}

function renderNeutralSkeleton(lm, ex) {
    if (!lm || lm.length === 0 || !ctx) return;
    
    const color = 'rgba(120, 220, 180, 0.9)'; // Neutral mint
    
    // Draw connections
    const connections = [
        [0, 1], [1, 2], [2, 3], [3, 4],
        [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12],
        [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20],
        [5, 9], [9, 13], [13, 17]
    ];
    
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    
    connections.forEach(([i, j]) => {
        const a = project(lm[i]);
        const b = project(lm[j]);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
    });
    
    // Draw joints
    lm.forEach((pt, idx) => {
        const p = project(pt);
        const isTip = FINGER_TIPS.includes(idx);
        const isTarget = ex && ex.targetFingers && ex.targetFingers.includes(getFingerIdx(idx)) && isTip;
        
        const size = isTarget ? 10 : isTip ? 7 : 5;
        
        // Subtle glow for targets
        if (isTarget) {
            ctx.shadowColor = '#5fffb0';
            ctx.shadowBlur = 15;
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
        ctx.fill();
        
        if (isTip) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(p.x, p.y, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.shadowBlur = 0;
    });
    
    // Wrist highlight
    const wrist = project(lm[0]);
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(wrist.x, wrist.y, 10, 0, Math.PI * 2);
    ctx.fill();
}

function getFingerIdx(nodeIdx) {
    if (nodeIdx >= 1 && nodeIdx <= 4) return 0;
    if (nodeIdx >= 5 && nodeIdx <= 8) return 1;
    if (nodeIdx >= 9 && nodeIdx <= 12) return 2;
    if (nodeIdx >= 13 && nodeIdx <= 16) return 3;
    if (nodeIdx >= 17 && nodeIdx <= 20) return 4;
    return -1;
}

function renderSpreadZones(lm) {
    const tips = FINGER_TIPS.map(i => project(lm[i]));
    const wrist = project(lm[0]);
    const frame = BoundaryEngine.getHandFrame(lm);
    
    for (let i = 0; i < tips.length - 1; i++) {
        const gap = Math.hypot(
            lm[FINGER_TIPS[i+1]].x - lm[FINGER_TIPS[i]].x,
            lm[FINGER_TIPS[i+1]].y - lm[FINGER_TIPS[i]].y
        ) / frame.handWidth;
        
        let zoneColor;
        if (gap > 0.20) zoneColor = 'rgba(104, 200, 150, 0.35)';
        else if (gap > 0.12) zoneColor = 'rgba(100, 180, 230, 0.35)';
        else if (gap > 0.06) zoneColor = 'rgba(240, 200, 100, 0.35)';
        else zoneColor = 'rgba(230, 130, 130, 0.25)';
        
        ctx.beginPath();
        ctx.moveTo(tips[i].x, tips[i].y);
        ctx.lineTo(tips[i + 1].x, tips[i + 1].y);
        ctx.lineTo(wrist.x, wrist.y);
        ctx.closePath();
        ctx.fillStyle = zoneColor;
        ctx.fill();
    }
}

function renderDebugBoundaries(lm, ex) {
    // Only shown when DEBUG=true
    const frame = BoundaryEngine.getHandFrame(lm);
    
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 5; i++) {
        const baseIdx = BoundaryEngine.FINGER_BASES[i];
        const base = project(lm[baseIdx]);
        
        // Green threshold line
        const greenY = base.y + (0.12 * frame.handHeight * el.canvas.height);
        ctx.strokeStyle = 'rgba(104, 200, 150, 0.5)';
        ctx.beginPath();
        ctx.moveTo(base.x - 20, greenY);
        ctx.lineTo(base.x + 20, greenY);
        ctx.stroke();
        
        // Yellow threshold line
        const yellowY = base.y + (0.04 * frame.handHeight * el.canvas.height);
        ctx.strokeStyle = 'rgba(240, 200, 100, 0.5)';
        ctx.beginPath();
        ctx.moveTo(base.x - 15, yellowY);
        ctx.lineTo(base.x + 15, yellowY);
        ctx.stroke();
    }
    
    ctx.setLineDash([]);
}

function renderIBEOverlay(lm, ex) {
    if (!lm || !ex) return;
    if (typeof InvisibleBoundaryEngine === 'undefined') return;
    if (typeof InvisibleBoundaryEngine._debugGetBoundaries !== 'function') return;

    const targetFingers = getExerciseTargetFingersForIBE(ex);
    if (!targetFingers || targetFingers.length === 0) return;

    const b = InvisibleBoundaryEngine._debugGetBoundaries(lm, targetFingers);
    if (!b || !b.greenBoundary || !b.acceptableBoundary || !b.lowBoundary) return;

    const L1 = toLinePx(b.greenBoundary);
    const L2 = toLinePx(b.acceptableBoundary);
    const L3 = toLinePx(b.lowBoundary);

    // === Filled zones (approximate the wireframe bands) ===
    // Zone between GREEN and ACCEPTABLE (safe/high accuracy)
    fillBetweenLines(L1, L2, 'rgba(72, 187, 120, 0.22)'); // green-ish

    // Zone between ACCEPTABLE and LOW (acceptable/mid accuracy)
    fillBetweenLines(L2, L3, 'rgba(59, 130, 246, 0.18)'); // blue-ish

    // Above GREEN line (low accuracy / warning band)
    fillCapAboveLine(L1, 'rgba(109, 40, 217, 0.12)'); // purple tint

    // === Boundary lines ===
    drawBoundaryLine(L1, 'rgba(34,197,94,0.95)', 5);     // GREEN
    drawBoundaryLine(L2, 'rgba(59,130,246,0.95)', 5);    // ACCEPTABLE
    drawBoundaryLine(L3, 'rgba(109,40,217,0.85)', 5);    // LOW

    // === Optional: Thumb red guideline (visual cue, not "perfect" physics yet) ===
    drawThumbRedLine(lm);

    // Labels (small, unobtrusive)
    drawZoneLabel('SAFE', midpoint(L1), 0, -10);
    drawZoneLabel('ACCEPTABLE', midpoint(L2), 0, -10);
    drawZoneLabel('LOW', midpoint(L3), 0, -10);
}

function getExerciseTargetFingersForIBE(ex) {
    // ex.targetFingers uses 0..4 finger indices
    if (Array.isArray(ex.targetFingers) && ex.targetFingers.length) return ex.targetFingers;

    // Pinch: map pinchPair landmark tip indices to finger indices
    if (ex.type === 'pinch' && Array.isArray(ex.pinchPair)) {
        const tips = ex.pinchPair;
        const fingerIdxs = tips.map(tipNode => {
            // FINGER_TIPS is [4,8,12,16,20] in your file
            const idx = FINGER_TIPS.indexOf(tipNode);
            return idx >= 0 ? idx : null;
        }).filter(v => v !== null);
        return fingerIdxs.length ? fingerIdxs : [2]; // fallback to middle
    }

    // Spread / fist / flat: treat as all fingers
    if (ex.type === 'spread' || ex.type === 'fist' || ex.type === 'flat') {
        return [0,1,2,3,4];
    }

    // Fallback
    return [2];
}

function toLinePx(line) {
    const a = project(line.start);
    const b = project(line.end);
    return { a, b };
}

function drawBoundaryLine(L, strokeStyle, lineWidth = 4) {
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = strokeStyle;
    ctx.setLineDash([10, 8]);
    ctx.lineCap = 'round';
    ctx.moveTo(L.a.x, L.a.y);
    ctx.lineTo(L.b.x, L.b.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
}

function fillBetweenLines(Ltop, Lbottom, fillStyle) {
    ctx.save();
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    ctx.moveTo(Ltop.a.x, Ltop.a.y);
    ctx.lineTo(Ltop.b.x, Ltop.b.y);
    ctx.lineTo(Lbottom.b.x, Lbottom.b.y);
    ctx.lineTo(Lbottom.a.x, Lbottom.a.y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function fillCapAboveLine(L, fillStyle) {
    // Fill from the line up to the top of the canvas (simple "cap")
    ctx.save();
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    ctx.moveTo(L.a.x, 0);
    ctx.lineTo(L.b.x, 0);
    ctx.lineTo(L.b.x, L.b.y);
    ctx.lineTo(L.a.x, L.a.y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawThumbRedLine(lm) {
    // Visual guideline along thumb edge (approx)
    const wrist = project(lm[0]);
    const thumbTip = project(lm[4]);
    const thumbMcp = project(lm[2]);

    // Extend line a bit past thumb tip for the wireframe feel
    const dx = thumbTip.x - thumbMcp.x;
    const dy = thumbTip.y - thumbMcp.y;
    const len = Math.hypot(dx, dy) || 1;
    const ex = (dx / len) * 80;
    const ey = (dy / len) * 80;

    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(239,68,68,0.9)'; // red
    ctx.lineCap = 'round';
    ctx.moveTo(wrist.x, wrist.y);
    ctx.lineTo(thumbTip.x + ex, thumbTip.y + ey);
    ctx.stroke();

    // red translucent zone near thumb
    ctx.globalAlpha = 0.18;
    ctx.beginPath();
    ctx.moveTo(wrist.x, wrist.y);
    ctx.lineTo(thumbTip.x + ex, thumbTip.y + ey);
    ctx.lineTo(thumbTip.x + ex + 30, thumbTip.y + ey + 30);
    ctx.closePath();
    ctx.fillStyle = 'rgba(239,68,68,1)';
    ctx.fill();

    ctx.restore();
}

function midpoint(L) {
    return { x: (L.a.x + L.b.x) / 2, y: (L.a.y + L.b.y) / 2 };
}

function drawZoneLabel(text, p, ox = 0, oy = 0) {
    ctx.save();
    ctx.font = '12px system-ui';
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillText(text, p.x + ox + 8, p.y + oy - 8);
    ctx.restore();
}

// ============================================
// PAIN CHECK & REST
// ============================================
function showPainCheck() {
    state.screen = 'PAIN';
    state.selectedPain = null;
    el.painAdvice.textContent = '';
    el.btnContinuePain.disabled = true;
    document.querySelectorAll('.pain-btn').forEach(b => b.classList.remove('selected'));
    el.pain.classList.remove('hidden');
}

function selectPain(level) {
    state.selectedPain = level;
    state.painLevels.push({ time: Date.now(), level });
    document.querySelectorAll('.pain-btn').forEach((b, i) => b.classList.toggle('selected', i === level));
    const advice = [
        "Excellent! You're doing great.",
        "Some mild discomfort is normal.",
        "Let's take it slower.",
        "Please stop and rest."
    ];
    el.painAdvice.textContent = advice[level];
    el.btnContinuePain.disabled = false;
    el.btnContinuePain.textContent = level === 3 ? 'End Session' : 'Continue';
}

function continuePain() {
    el.pain.classList.add('hidden');
    if (state.selectedPain === 3) { endSession(); return; }
    showRest();
}

let restInterval = null;
function showRest() {
    state.screen = 'REST';
    let remaining = CONFIG.REST_SECONDS;
    el.restTimer.textContent = remaining;
    el.rest.classList.remove('hidden');
    
    restInterval = setInterval(() => {
        remaining--;
        el.restTimer.textContent = remaining;
        if (remaining <= 0) skipRest();
    }, 1000);
}

function skipRest() {
    if (restInterval) { 
        clearInterval(restInterval); 
        restInterval = null; 
    }
    el.rest.classList.add('hidden');
    
    // Ensure tracker state is clean
    state.landmarks = null;
    state.progress = 0;
    relaxedResetBuffer = [];
    
    const nextIdx = state.exIdx + 1;
    if (nextIdx >= state.exercises.length) {
        endSession();
    } else { 
        state.cooldown = false;
        showReadyScreen(nextIdx); 
    }
}

// ============================================
// SESSION END
// ============================================
function endSession() {
    state.screen = 'COMPLETE';
    hideControls();
    
    if (state.animationFrameId) {
        cancelAnimationFrame(state.animationFrameId);
        state.animationFrameId = null;
    }
    
    const duration = Math.floor((Date.now() - state.startTime) / 1000);
    const valid = state.log.filter(l => !l.skipped);
    const avgAcc = valid.length > 0 ? valid.reduce((s, l) => s + l.accuracy, 0) / valid.length : 0;
    
    let grade, gradeClass;
    if (avgAcc >= 85) { grade = 'A'; gradeClass = 'grade-a'; }
    else if (avgAcc >= 70) { grade = 'B+'; gradeClass = 'grade-b'; }
    else if (avgAcc >= 55) { grade = 'B'; gradeClass = 'grade-b'; }
    else { grade = 'C+'; gradeClass = 'grade-c'; }
    
    el.sumDone.textContent = state.completed;
    el.sumTime.textContent = `${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}`;
    el.sumStreak.textContent = state.bestStreak + ' üî•';
    el.sumAccuracy.textContent = Math.round(avgAcc) + '%';
    el.sumGrade.textContent = grade;
    el.sumGrade.className = 'grade-badge ' + gradeClass;
    
    el.complete.classList.remove('hidden');
    
    saveSessionResult(avgAcc, grade, duration);
}

function saveSessionResult(avgAcc, grade, duration) {
    const result = {
        completed: state.completed,
        duration: `${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}`,
        grade: grade,
        avgAccuracy: Math.round(avgAcc),
        bestStreak: state.bestStreak,
        exercises: state.log,
        date: new Date().toISOString()
    };
    
    try {
        localStorage.setItem('handhero_lastSessionResult', JSON.stringify(result));
        showToast(`Session saved! ${state.completed} exercises, ${grade} grade`, '‚úÖ');
    } catch (e) {
        console.error('Save error:', e);
    }
}

// ============================================
// NAVIGATION
// ============================================
function goHome() {
    window.location.href = 'handhero_dashboard.html';
}

function confirmRestart() {
    showModal('Start New Session?', 'Ready for another round?', () => {
        closeModal();
        el.complete.classList.add('hidden');
        showControls();
        beginSession();
    });
}

function showModal(title, desc, onConfirm) {
    el.modalTitle.textContent = title;
    el.modalDesc.textContent = desc;
    state.modalAction = onConfirm;
    el.modal.classList.add('show');
}

function closeModal() {
    el.modal.classList.remove('show');
    state.modalAction = null;
}

function confirmModalAction() {
    if (state.modalAction) state.modalAction();
}

function handleHomeClick() {
    if (state.screen === 'SESSION' && state.completed > 0) {
        showModal('Leave Session?', 'Your progress will be saved.', () => {
            const duration = Math.floor((Date.now() - state.startTime) / 1000);
            const valid = state.log.filter(l => !l.skipped);
            const avgAcc = valid.length > 0 ? valid.reduce((s, l) => s + l.accuracy, 0) / valid.length : 0;
            saveSessionResult(avgAcc, 'Incomplete', duration);
            goHome();
        });
    } else {
        goHome();
    }
}

function exportReport() {
    const duration = Math.floor((Date.now() - state.startTime) / 1000);
    const txt = `HANDHERO SESSION REPORT\n${'='.repeat(40)}\nDate: ${new Date().toLocaleString()}\n\nSUMMARY\n${'-'.repeat(20)}\nExercises: ${state.completed}\nDuration: ${Math.floor(duration/60)}:${(duration%60).toString().padStart(2,'0')}\nBest Streak: ${state.bestStreak}\n\nDETAILS\n${'-'.repeat(20)}\n${state.log.map(l => `${l.name}: ${l.accuracy}% (${l.grade})`).join('\n')}\n\n---\nGenerated by HandHero`;
    const blob = new Blob([txt], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `handhero-${new Date().toISOString().split('T')[0]}.txt`;
    a.click();
}

// ============================================
// AUDIO & FEEDBACK
// ============================================
function showFeedback(text) {
    el.feedback.textContent = text;
    el.feedback.classList.add('show');
    setTimeout(() => el.feedback.classList.remove('show'), 1200);
}

function spawnParticles() {
    const colors = ['#68c896', '#64b4e6', '#f0c864', '#a8c99b'];
    for (let i = 0; i < 20; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        p.style.left = (25 + Math.random() * 50) + '%';
        p.style.top = (25 + Math.random() * 30) + '%';
        p.style.width = p.style.height = (6 + Math.random() * 10) + 'px';
        p.style.background = colors[Math.floor(Math.random() * colors.length)];
        el.view.appendChild(p);
        setTimeout(() => p.remove(), 2000);
    }
}

function playSound() {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'sine';
    o.frequency.setValueAtTime(523, audioCtx.currentTime);
    o.frequency.setValueAtTime(659, audioCtx.currentTime + 0.1);
    o.frequency.setValueAtTime(784, audioCtx.currentTime + 0.2);
    g.gain.setValueAtTime(0.1, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
    o.start(); o.stop(audioCtx.currentTime + 0.5);
}

const coach = {
    enabled: true,
    toggle() {
        this.enabled = !this.enabled;
        el.btnAudio.textContent = this.enabled ? 'üîä' : 'üîá';
    }
};

function speak(text) {
    if (!coach.enabled || !window.speechSynthesis) return;
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 0.9;
    speechSynthesis.speak(u);
}

// ============================================
// EVENT LISTENERS
// ============================================
el.btnHome.addEventListener('click', handleHomeClick);
el.btnAudio.addEventListener('click', () => coach.toggle());
el.btnSkip.addEventListener('click', skipExercise);

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') handleHomeClick();
    if (e.key === 's' && state.screen === 'SESSION') skipExercise();
});

el.modal.addEventListener('click', (e) => {
    if (e.target === el.modal) closeModal();
});

el.modalSkip.addEventListener('click', (e) => {
    if (e.target === el.modalSkip) closeSkipModal();
});

// ============================================
// INIT
// ============================================
console.log('%cüå± HandHero v6.0 Merged', 'font-size: 24px; font-weight: bold; color: #68c896;');
console.log('%cBoundaryEngine + Soft Decay + Color Indicators', 'font-size: 14px; color: #64b4e6;');
</script>
</body>
</html>