<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HandHero Demo | Boundary-Based Detection</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-cream: #fdfbf7;
            --color-sage: #87a878;
            --color-sage-dark: #6b9960;
            --color-coral: #e8998d;
            --color-gold: #d4a574;
            --color-slate: #4a5568;
            --color-slate-light: #718096;
            
            --zone-green: rgba(104, 200, 150, 0.5);
            --zone-green-solid: #68c896;
            --zone-blue: rgba(100, 180, 230, 0.5);
            --zone-blue-solid: #64b4e6;
            --zone-yellow: rgba(240, 200, 100, 0.5);
            --zone-yellow-solid: #f0c864;
            --zone-red: rgba(230, 130, 130, 0.5);
            --zone-red-solid: #e68282;
            
            --skeleton-color: #78dcb4;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Nunito', sans-serif;
            background: var(--color-cream);
            color: var(--color-slate);
            overflow: hidden;
            user-select: none;
        }
        
        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #video-container {
            position: relative;
            width: 90vw;
            height: 85vh;
            max-width: 1100px;
            border-radius: 28px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            background: #1a1a2e;
        }
        
        #video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* HUD Elements */
        .hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .glass-card {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(16px);
            border-radius: 16px;
            padding: 16px 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        
        .exercise-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .exercise-icon {
            font-size: 2.5rem;
        }
        
        .exercise-name {
            font-size: 1.3rem;
            font-weight: 800;
            color: var(--color-slate);
        }
        
        .exercise-desc {
            font-size: 0.9rem;
            color: var(--color-slate-light);
        }
        
        /* Accuracy Display */
        .accuracy-card {
            text-align: center;
            min-width: 120px;
        }
        
        .accuracy-value {
            font-size: 2.5rem;
            font-weight: 800;
            transition: color 0.3s;
        }
        
        .accuracy-value.green { color: var(--zone-green-solid); }
        .accuracy-value.blue { color: var(--zone-blue-solid); }
        .accuracy-value.yellow { color: var(--zone-yellow-solid); }
        .accuracy-value.red { color: var(--zone-red-solid); }
        
        .accuracy-label {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--color-slate-light);
        }
        
        /* Phase Indicator */
        .phase-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .phase-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e0e0e0;
            transition: all 0.3s;
        }
        
        .phase-dot.active { background: var(--color-sage); transform: scale(1.2); }
        .phase-dot.complete { background: var(--zone-green-solid); }
        
        .phase-label {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--color-sage);
        }
        
        /* Progress Bar */
        .progress-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: rgba(0,0,0,0.1);
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--color-sage), var(--zone-green-solid));
            transition: width 0.1s;
        }
        
        /* Center Feedback */
        .center-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        
        .big-message {
            font-size: 3rem;
            font-weight: 800;
            color: white;
            text-shadow: 0 4px 30px rgba(0,0,0,0.4);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .big-message.show { opacity: 1; }
        
        /* Zone Legend */
        .zone-legend {
            position: absolute;
            bottom: 30px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 0.75rem;
        }
        
        .zone-legend-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--color-slate);
        }
        
        .zone-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        
        .zone-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .zone-dot.green { background: var(--zone-green-solid); }
        .zone-dot.blue { background: var(--zone-blue-solid); }
        .zone-dot.yellow { background: var(--zone-yellow-solid); }
        .zone-dot.red { background: var(--zone-red-solid); }
        
        /* Exercise Buttons */
        .exercise-nav {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        
        .nav-btn {
            background: white;
            border: none;
            padding: 12px 20px;
            border-radius: 12px;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        
        .nav-btn.primary {
            background: var(--color-sage);
            color: white;
        }
        
        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
        }
        
        .finger-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .finger-status:last-child { border-bottom: none; }
        
        .finger-name {
            width: 60px;
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        .finger-bar {
            flex: 1;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .finger-bar-fill {
            height: 100%;
            transition: width 0.2s, background 0.2s;
        }
        
        .finger-zone {
            width: 20px;
            font-size: 0.7rem;
            font-weight: 700;
            text-align: center;
        }
        
        /* Start Screen */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(253, 251, 247, 0.98);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.4s;
        }
        
        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-content {
            text-align: center;
            max-width: 500px;
            padding: 40px;
        }
        
        .start-logo {
            font-size: 4rem;
            margin-bottom: 20px;
        }
        
        .start-title {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 12px;
            color: var(--color-slate);
        }
        
        .start-desc {
            color: var(--color-slate-light);
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .start-btn {
            background: linear-gradient(135deg, var(--color-sage), var(--color-sage-dark));
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 16px;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(135, 168, 120, 0.4);
            transition: all 0.2s;
        }
        
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(135, 168, 120, 0.5);
        }
        
        /* Loading State */
        .loading-text {
            color: var(--color-slate-light);
            margin-top: 20px;
        }
        
        /* Debug Toggle */
        .debug-toggle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 50;
        }
        
        .debug-toggle label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            
            <div class="hud">
                <div class="hud-top">
                    <div class="glass-card">
                        <div class="exercise-info">
                            <span class="exercise-icon" id="ex-icon">‚òùÔ∏è</span>
                            <div>
                                <div class="exercise-name" id="ex-name">Index Finger</div>
                                <div class="exercise-desc" id="ex-desc">Extend only your index finger</div>
                            </div>
                        </div>
                        <div class="phase-indicator">
                            <div class="phase-dot" id="phase-1"></div>
                            <div class="phase-dot" id="phase-2"></div>
                            <span class="phase-label" id="phase-label">Ready</span>
                        </div>
                    </div>
                    
                    <div class="glass-card accuracy-card">
                        <div class="accuracy-value" id="accuracy">0%</div>
                        <div class="accuracy-label">Accuracy</div>
                    </div>
                </div>
            </div>
            
            <div class="center-feedback">
                <div class="big-message" id="big-message">Perfect!</div>
            </div>
            
            <div class="progress-container">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            
            <div class="zone-legend">
                <div class="zone-legend-title">Accuracy Zones</div>
                <div class="zone-item"><div class="zone-dot green"></div> 85%+ Perfect</div>
                <div class="zone-item"><div class="zone-dot blue"></div> 65%+ Good</div>
                <div class="zone-item"><div class="zone-dot yellow"></div> 40%+ Keep trying</div>
                <div class="zone-item"><div class="zone-dot red"></div> Below 40%</div>
            </div>
            
            <div class="exercise-nav">
                <button class="nav-btn" id="btn-prev">‚Üê Previous</button>
                <button class="nav-btn" id="btn-skip">Skip ‚Üí</button>
                <button class="nav-btn primary" id="btn-next">Next Exercise</button>
            </div>
            
            <div class="glass-card status-panel" id="status-panel">
                <div class="finger-status">
                    <span class="finger-name">Thumb</span>
                    <div class="finger-bar"><div class="finger-bar-fill" id="bar-thumb"></div></div>
                    <span class="finger-zone" id="zone-thumb">-</span>
                </div>
                <div class="finger-status">
                    <span class="finger-name">Index</span>
                    <div class="finger-bar"><div class="finger-bar-fill" id="bar-index"></div></div>
                    <span class="finger-zone" id="zone-index">-</span>
                </div>
                <div class="finger-status">
                    <span class="finger-name">Middle</span>
                    <div class="finger-bar"><div class="finger-bar-fill" id="bar-middle"></div></div>
                    <span class="finger-zone" id="zone-middle">-</span>
                </div>
                <div class="finger-status">
                    <span class="finger-name">Ring</span>
                    <div class="finger-bar"><div class="finger-bar-fill" id="bar-ring"></div></div>
                    <span class="finger-zone" id="zone-ring">-</span>
                </div>
                <div class="finger-status">
                    <span class="finger-name">Pinky</span>
                    <div class="finger-bar"><div class="finger-bar-fill" id="bar-pinky"></div></div>
                    <span class="finger-zone" id="zone-pinky">-</span>
                </div>
            </div>
            
            <div class="debug-toggle">
                <label><input type="checkbox" id="show-boundaries" checked> Show Boundaries</label>
                <label><input type="checkbox" id="show-skeleton" checked> Show Skeleton</label>
            </div>
        </div>
        
        <!-- Start Overlay -->
        <div class="overlay" id="start-overlay">
            <div class="start-content">
                <div class="start-logo">üñêÔ∏è</div>
                <h1 class="start-title">HandHero Demo</h1>
                <p class="start-desc">
                    Boundary-based hand tracking that uses <strong>human logic</strong> to measure accuracy, 
                    not AI precision. See how natural movements are evaluated with forgiveness built in.
                </p>
                <button class="start-btn" id="start-btn">Start Demo</button>
                <p class="loading-text" id="loading-text" style="display:none;">Loading hand tracking...</p>
            </div>
        </div>
    </div>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- Boundary Engine -->
    <script>
    /**
     * HandHero Boundary-Based Detection Engine (Inline)
     */
    const BoundaryEngine = {
        FINGERS: {
            THUMB:  { base: 1, mid: 2, dip: 3, tip: 4, name: 'Thumb' },
            INDEX:  { base: 5, mid: 6, dip: 7, tip: 8, name: 'Index' },
            MIDDLE: { base: 9, mid: 10, dip: 11, tip: 12, name: 'Middle' },
            RING:   { base: 13, mid: 14, dip: 15, tip: 16, name: 'Ring' },
            PINKY:  { base: 17, mid: 18, dip: 19, tip: 20, name: 'Pinky' }
        },
        
        FINGER_ORDER: ['THUMB', 'INDEX', 'MIDDLE', 'RING', 'PINKY'],
        TIPS: [4, 8, 12, 16, 20],
        BASES: [1, 5, 9, 13, 17],
        
        ZONES: {
            GREEN_THRESHOLD: 0.12,
            YELLOW_THRESHOLD: 0.04,
            RED_THRESHOLD: 0.0,
        },
        
        THUMB_BOUNDARY: 0.15,
        
        getHandFrame(landmarks) {
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const indexBase = landmarks[5];
            const pinkyBase = landmarks[17];
            
            const handHeight = Math.sqrt(
                Math.pow(middleTip.x - wrist.x, 2) + 
                Math.pow(middleTip.y - wrist.y, 2) +
                Math.pow((middleTip.z || 0) - (wrist.z || 0), 2)
            );
            
            const handWidth = Math.sqrt(
                Math.pow(pinkyBase.x - indexBase.x, 2) + 
                Math.pow(pinkyBase.y - indexBase.y, 2)
            );
            
            const palmCenter = {
                x: (landmarks[0].x + landmarks[5].x + landmarks[9].x + landmarks[13].x + landmarks[17].x) / 5,
                y: (landmarks[0].y + landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 5
            };
            
            const baseLineY = (landmarks[5].y + landmarks[9].y + landmarks[13].y + landmarks[17].y) / 4;
            
            return { handHeight, handWidth, palmCenter, baseLineY, wrist, landmarks };
        },
        
        checkNonTargetFinger(fingerIndex, landmarks, handFrame) {
            const finger = this.FINGERS[this.FINGER_ORDER[fingerIndex]];
            const tip = landmarks[finger.tip];
            const base = landmarks[finger.base];
            
            const tipBelowBase = tip.y - base.y;
            const normalizedDistance = tipBelowBase / handFrame.handHeight;
            
            if (normalizedDistance >= this.ZONES.GREEN_THRESHOLD) {
                return { zone: 'GREEN', score: 1.0 };
            } else if (normalizedDistance >= this.ZONES.YELLOW_THRESHOLD) {
                const progress = (normalizedDistance - this.ZONES.YELLOW_THRESHOLD) / 
                               (this.ZONES.GREEN_THRESHOLD - this.ZONES.YELLOW_THRESHOLD);
                return { zone: 'YELLOW', score: 0.65 + (progress * 0.20) };
            } else if (normalizedDistance >= this.ZONES.RED_THRESHOLD) {
                const progress = (normalizedDistance - this.ZONES.RED_THRESHOLD) / 
                               (this.ZONES.YELLOW_THRESHOLD - this.ZONES.RED_THRESHOLD);
                return { zone: 'ORANGE', score: 0.40 + (progress * 0.25) };
            } else {
                return { zone: 'RED', score: Math.max(0.15, 0.40 + normalizedDistance * 2) };
            }
        },
        
        checkTargetFinger(fingerIndex, landmarks, handFrame) {
            const finger = this.FINGERS[this.FINGER_ORDER[fingerIndex]];
            const tip = landmarks[finger.tip];
            const base = landmarks[finger.base];
            const wrist = landmarks[0];
            
            const tipAboveBase = base.y - tip.y;
            const normalizedExtension = tipAboveBase / handFrame.handHeight;
            
            const tipToWrist = Math.sqrt(
                Math.pow(tip.x - wrist.x, 2) + 
                Math.pow(tip.y - wrist.y, 2)
            );
            const baseToWrist = Math.sqrt(
                Math.pow(base.x - wrist.x, 2) + 
                Math.pow(base.y - wrist.y, 2)
            );
            const extensionRatio = tipToWrist / baseToWrist;
            
            if (normalizedExtension > 0.08 && extensionRatio > 1.2) {
                return { zone: 'GREEN', score: 1.0 };
            } else if (normalizedExtension > 0.03 && extensionRatio > 1.1) {
                return { zone: 'BLUE', score: 0.85 };
            } else if (normalizedExtension > -0.02 && extensionRatio > 0.95) {
                return { zone: 'YELLOW', score: 0.65 };
            } else {
                return { zone: 'RED', score: Math.max(0.20, 0.50 + normalizedExtension) };
            }
        },
        
        checkThumbBoundary(landmarks, handFrame) {
            const thumbTip = landmarks[4];
            const indexBase = landmarks[5];
            const middleBase = landmarks[9];
            
            // Simple check: thumb should not be past index finger horizontally
            const thumbPastIndex = Math.abs(thumbTip.x - indexBase.x) < handFrame.handWidth * 0.5;
            
            if (thumbPastIndex) {
                return { zone: 'GREEN', score: 1.0 };
            } else {
                return { zone: 'YELLOW', score: 0.7 };
            }
        },
        
        evaluateIsolation(landmarks, targetFingers) {
            const handFrame = this.getHandFrame(landmarks);
            const fingerResults = [];
            let totalScore = 0;
            let worstZone = 'GREEN';
            const zoneRank = { 'GREEN': 4, 'BLUE': 3, 'YELLOW': 2, 'ORANGE': 1, 'RED': 0 };
            
            for (let i = 0; i < 5; i++) {
                const isTarget = targetFingers.includes(i);
                let result;
                
                if (i === 0 && !isTarget) {
                    result = this.checkThumbBoundary(landmarks, handFrame);
                } else if (isTarget) {
                    result = this.checkTargetFinger(i, landmarks, handFrame);
                } else {
                    result = this.checkNonTargetFinger(i, landmarks, handFrame);
                }
                
                result.isTarget = isTarget;
                result.fingerName = this.FINGER_ORDER[i];
                fingerResults.push(result);
                
                totalScore += result.score;
                
                if (zoneRank[result.zone] < zoneRank[worstZone]) {
                    worstZone = result.zone;
                }
            }
            
            const accuracy = totalScore / 5;
            
            let overallZone;
            if (accuracy >= 0.85) overallZone = 'GREEN';
            else if (accuracy >= 0.65) overallZone = 'BLUE';
            else if (accuracy >= 0.40) overallZone = 'YELLOW';
            else overallZone = 'RED';
            
            return {
                accuracy,
                overallZone,
                worstZone,
                fingerResults,
                passed: accuracy >= 0.65,
                handFrame
            };
        },
        
        evaluateSpread(landmarks) {
            const handFrame = this.getHandFrame(landmarks);
            
            let extensionScore = 0;
            for (let i = 0; i < 5; i++) {
                const result = this.checkTargetFinger(i, landmarks, handFrame);
                extensionScore += result.score;
            }
            extensionScore /= 5;
            
            const tips = this.TIPS.map(i => landmarks[i]);
            let gapScore = 0;
            for (let i = 0; i < tips.length - 1; i++) {
                const gap = Math.sqrt(
                    Math.pow(tips[i + 1].x - tips[i].x, 2) +
                    Math.pow(tips[i + 1].y - tips[i].y, 2)
                );
                const normalizedGap = gap / handFrame.handWidth;
                
                if (normalizedGap > 0.18) gapScore += 1.0;
                else if (normalizedGap > 0.10) gapScore += 0.75;
                else if (normalizedGap > 0.05) gapScore += 0.50;
                else gapScore += 0.25;
            }
            gapScore /= 4;
            
            const accuracy = (extensionScore * 0.5) + (gapScore * 0.5);
            
            let overallZone;
            if (accuracy >= 0.85) overallZone = 'GREEN';
            else if (accuracy >= 0.65) overallZone = 'BLUE';
            else if (accuracy >= 0.40) overallZone = 'YELLOW';
            else overallZone = 'RED';
            
            // Return finger results for spread (all targets)
            const fingerResults = [];
            for (let i = 0; i < 5; i++) {
                const result = this.checkTargetFinger(i, landmarks, handFrame);
                result.isTarget = true;
                result.fingerName = this.FINGER_ORDER[i];
                fingerResults.push(result);
            }
            
            return { accuracy, overallZone, fingerResults, passed: accuracy >= 0.65, handFrame };
        }
    };
    </script>
    
    <!-- Main App -->
    <script>
    // ============================================
    // EXERCISES
    // ============================================
    const EXERCISES = [
        { id: 'index', name: 'Index Finger', icon: '‚òùÔ∏è', desc: 'Extend only your index finger', targets: [1], type: 'isolation' },
        { id: 'middle', name: 'Middle Finger', icon: 'üñï', desc: 'Extend only your middle finger', targets: [2], type: 'isolation' },
        { id: 'ring', name: 'Ring Finger', icon: 'üíç', desc: 'Extend only your ring finger', targets: [3], type: 'isolation' },
        { id: 'pinky', name: 'Pinky Finger', icon: 'ü§ô', desc: 'Extend only your pinky finger', targets: [4], type: 'isolation' },
        { id: 'thumb', name: 'Thumbs Up', icon: 'üëç', desc: 'Extend only your thumb', targets: [0], type: 'isolation' },
        { id: 'peace', name: 'Peace Sign', icon: '‚úåÔ∏è', desc: 'Extend index and middle fingers', targets: [1, 2], type: 'isolation' },
        { id: 'spread', name: 'Full Spread', icon: 'üñêÔ∏è', desc: 'Spread all fingers wide', targets: [0,1,2,3,4], type: 'spread' },
    ];
    
    // ============================================
    // STATE
    // ============================================
    const state = {
        currentExercise: 0,
        hands: null,
        camera: null,
        landmarks: null,
        lastResult: null,
        progress: 0,
        holding: false,
        holdStart: 0,
        showBoundaries: true,
        showSkeleton: true
    };
    
    // ============================================
    // DOM
    // ============================================
    const $ = id => document.getElementById(id);
    const video = $('video');
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    
    // ============================================
    // MEDIAPIPE SETUP
    // ============================================
    async function initHands() {
        $('loading-text').style.display = 'block';
        $('start-btn').style.display = 'none';
        
        state.hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        
        state.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.6
        });
        
        state.hands.onResults(onResults);
        
        state.camera = new Camera(video, {
            onFrame: async () => {
                await state.hands.send({ image: video });
            },
            width: 1280,
            height: 720
        });
        
        await state.camera.start();
        
        $('start-overlay').classList.add('hidden');
    }
    
    // ============================================
    // HAND PROCESSING
    // ============================================
    function onResults(results) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            state.landmarks = results.multiHandLandmarks[0];
            processHand(state.landmarks);
        } else {
            state.landmarks = null;
            updateUI(null);
        }
    }
    
    function processHand(landmarks) {
        const ex = EXERCISES[state.currentExercise];
        let result;
        
        if (ex.type === 'spread') {
            result = BoundaryEngine.evaluateSpread(landmarks);
        } else {
            result = BoundaryEngine.evaluateIsolation(landmarks, ex.targets);
        }
        
        state.lastResult = result;
        
        // Update hold/progress
        if (result.accuracy >= 0.65) {
            if (!state.holding) {
                state.holding = true;
                state.holdStart = Date.now();
            }
            const holdTime = Date.now() - state.holdStart;
            state.progress = Math.min(1, holdTime / 2000); // 2 second hold
        } else {
            state.holding = false;
            state.progress = Math.max(0, state.progress - 0.015); // Slow decay
        }
        
        // Render
        if (state.showSkeleton) renderSkeleton(landmarks, result);
        if (state.showBoundaries) renderBoundaries(landmarks, result);
        
        updateUI(result);
        
        // Success check
        if (state.progress >= 1) {
            showSuccess();
        }
    }
    
    // ============================================
    // RENDERING
    // ============================================
    function renderSkeleton(landmarks, result) {
        const CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8],       // Index
            [0, 9], [9, 10], [10, 11], [11, 12],  // Middle
            [0, 13], [13, 14], [14, 15], [15, 16],// Ring
            [0, 17], [17, 18], [18, 19], [19, 20],// Pinky
            [5, 9], [9, 13], [13, 17]             // Palm
        ];
        
        const skeletonColor = '#78dcb4';
        
        // Draw connections
        ctx.strokeStyle = skeletonColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        for (const [i, j] of CONNECTIONS) {
            const a = landmarks[i];
            const b = landmarks[j];
            ctx.beginPath();
            ctx.moveTo(a.x * canvas.width, a.y * canvas.height);
            ctx.lineTo(b.x * canvas.width, b.y * canvas.height);
            ctx.stroke();
        }
        
        // Draw joints
        const ex = EXERCISES[state.currentExercise];
        
        landmarks.forEach((lm, idx) => {
            const x = lm.x * canvas.width;
            const y = lm.y * canvas.height;
            
            // Determine if this is a target fingertip
            const fingerIdx = getFingerFromNode(idx);
            const isTargetTip = BoundaryEngine.TIPS.includes(idx) && ex.targets.includes(fingerIdx);
            
            const size = isTargetTip ? 10 : 6;
            
            // Glow for target tips
            if (isTargetTip) {
                ctx.shadowColor = skeletonColor;
                ctx.shadowBlur = 15;
            }
            
            ctx.fillStyle = skeletonColor;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // White center for tips
            if (BoundaryEngine.TIPS.includes(idx)) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
        });
    }
    
    function getFingerFromNode(nodeIdx) {
        if (nodeIdx >= 1 && nodeIdx <= 4) return 0;   // Thumb
        if (nodeIdx >= 5 && nodeIdx <= 8) return 1;   // Index
        if (nodeIdx >= 9 && nodeIdx <= 12) return 2;  // Middle
        if (nodeIdx >= 13 && nodeIdx <= 16) return 3; // Ring
        if (nodeIdx >= 17 && nodeIdx <= 20) return 4; // Pinky
        return -1;
    }
    
    function renderBoundaries(landmarks, result) {
        const ex = EXERCISES[state.currentExercise];
        const handFrame = result.handFrame;
        
        // Draw boundary lines for non-target fingers
        for (let i = 1; i < 5; i++) { // Skip thumb for now
            if (ex.targets.includes(i)) continue; // Skip target fingers
            
            const finger = BoundaryEngine.FINGERS[BoundaryEngine.FINGER_ORDER[i]];
            const base = landmarks[finger.base];
            const tip = landmarks[finger.tip];
            
            const baseX = base.x * canvas.width;
            const baseY = base.y * canvas.height;
            const tipX = tip.x * canvas.width;
            const tipY = tip.y * canvas.height;
            
            // Green boundary line
            const greenY = baseY + (BoundaryEngine.ZONES.GREEN_THRESHOLD * handFrame.handHeight * canvas.height);
            
            // Yellow boundary line  
            const yellowY = baseY + (BoundaryEngine.ZONES.YELLOW_THRESHOLD * handFrame.handHeight * canvas.height);
            
            // Draw lines
            ctx.setLineDash([6, 4]);
            
            // Green line
            ctx.strokeStyle = 'rgba(104, 200, 150, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(baseX - 25, greenY);
            ctx.lineTo(baseX + 25, greenY);
            ctx.stroke();
            
            // Yellow line
            ctx.strokeStyle = 'rgba(240, 200, 100, 0.6)';
            ctx.beginPath();
            ctx.moveTo(baseX - 20, yellowY);
            ctx.lineTo(baseX + 20, yellowY);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Draw zone fill if tip is in zone
            const fingerResult = result.fingerResults[i];
            if (fingerResult && !fingerResult.isTarget) {
                const zoneColor = getZoneColor(fingerResult.zone);
                
                // Subtle zone highlight
                ctx.fillStyle = zoneColor;
                ctx.beginPath();
                ctx.arc(tipX, tipY, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw target zone for target fingers
        ex.targets.forEach(fingerIdx => {
            if (fingerIdx === 0) return; // Skip thumb special handling
            
            const tip = landmarks[BoundaryEngine.TIPS[fingerIdx]];
            const x = tip.x * canvas.width;
            const y = tip.y * canvas.height;
            
            const fingerResult = result.fingerResults[fingerIdx];
            const zoneColor = getZoneColor(fingerResult.zone);
            
            // Pulsing target zone
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
            
            ctx.fillStyle = zoneColor;
            ctx.beginPath();
            ctx.arc(x, y, 25 * pulse, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    function getZoneColor(zone) {
        switch(zone) {
            case 'GREEN': return 'rgba(104, 200, 150, 0.4)';
            case 'BLUE': return 'rgba(100, 180, 230, 0.4)';
            case 'YELLOW': return 'rgba(240, 200, 100, 0.4)';
            case 'ORANGE': return 'rgba(240, 160, 100, 0.4)';
            case 'RED': return 'rgba(230, 130, 130, 0.4)';
            default: return 'rgba(200, 200, 200, 0.3)';
        }
    }
    
    // ============================================
    // UI UPDATES
    // ============================================
    function updateUI(result) {
        const ex = EXERCISES[state.currentExercise];
        
        $('ex-icon').textContent = ex.icon;
        $('ex-name').textContent = ex.name;
        $('ex-desc').textContent = ex.desc;
        
        if (!result) {
            $('accuracy').textContent = '--';
            $('accuracy').className = 'accuracy-value';
            $('progress-fill').style.width = '0%';
            return;
        }
        
        // Accuracy
        const pct = Math.round(result.accuracy * 100);
        $('accuracy').textContent = pct + '%';
        $('accuracy').className = 'accuracy-value ' + result.overallZone.toLowerCase();
        
        // Progress bar
        $('progress-fill').style.width = (state.progress * 100) + '%';
        
        // Phase indicator
        $('phase-1').className = 'phase-dot ' + (state.progress > 0 ? 'complete' : 'active');
        $('phase-2').className = 'phase-dot ' + (state.progress >= 1 ? 'complete' : (state.progress > 0 ? 'active' : ''));
        $('phase-label').textContent = state.progress >= 1 ? 'Complete!' : (state.holding ? 'Hold...' : 'Get ready');
        
        // Finger status bars
        const fingerNames = ['thumb', 'index', 'middle', 'ring', 'pinky'];
        result.fingerResults.forEach((fr, i) => {
            const bar = $('bar-' + fingerNames[i]);
            const zone = $('zone-' + fingerNames[i]);
            
            bar.style.width = (fr.score * 100) + '%';
            bar.style.background = getZoneSolidColor(fr.zone);
            
            zone.textContent = fr.isTarget ? 'üéØ' : (fr.zone === 'GREEN' ? '‚úì' : fr.zone[0]);
        });
    }
    
    function getZoneSolidColor(zone) {
        switch(zone) {
            case 'GREEN': return '#68c896';
            case 'BLUE': return '#64b4e6';
            case 'YELLOW': return '#f0c864';
            case 'ORANGE': return '#f0a050';
            case 'RED': return '#e68282';
            default: return '#ccc';
        }
    }
    
    function showSuccess() {
        const msg = $('big-message');
        msg.textContent = ['Perfect! üåü', 'Excellent!', 'Great job!'][Math.floor(Math.random() * 3)];
        msg.classList.add('show');
        
        setTimeout(() => {
            msg.classList.remove('show');
            nextExercise();
        }, 1500);
    }
    
    // ============================================
    // NAVIGATION
    // ============================================
    function nextExercise() {
        state.currentExercise = (state.currentExercise + 1) % EXERCISES.length;
        resetExercise();
    }
    
    function prevExercise() {
        state.currentExercise = (state.currentExercise - 1 + EXERCISES.length) % EXERCISES.length;
        resetExercise();
    }
    
    function resetExercise() {
        state.progress = 0;
        state.holding = false;
        state.holdStart = 0;
    }
    
    // ============================================
    // EVENT LISTENERS
    // ============================================
    $('start-btn').addEventListener('click', initHands);
    $('btn-next').addEventListener('click', nextExercise);
    $('btn-prev').addEventListener('click', prevExercise);
    $('btn-skip').addEventListener('click', nextExercise);
    
    $('show-boundaries').addEventListener('change', (e) => {
        state.showBoundaries = e.target.checked;
    });
    
    $('show-skeleton').addEventListener('change', (e) => {
        state.showSkeleton = e.target.checked;
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight') nextExercise();
        if (e.key === 'ArrowLeft') prevExercise();
    });
    </script>
</body>
</html>